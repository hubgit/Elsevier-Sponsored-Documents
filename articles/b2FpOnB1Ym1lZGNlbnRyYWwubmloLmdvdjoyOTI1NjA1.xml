<article xmlns="http://dtd.nlm.nih.gov/2.0/xsd/archivearticle" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://dtd.nlm.nih.gov/2.0/xsd/archivearticle http://dtd.nlm.nih.gov/2.0/xsd/archivearticle.xsd" article-type="research-article">
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-ta">Comput Graph</journal-id>
      <journal-title-group>
        <journal-title>Computers &amp; Graphics</journal-title>
      </journal-title-group>
      <issn pub-type="ppub">0097-8493</issn>
      <publisher>
        <publisher-name>Pergamon Press</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmc">2925605</article-id>
      <article-id pub-id-type="pmid">20862189</article-id>
      <article-id pub-id-type="publisher-id">CAG2003</article-id>
      <article-id pub-id-type="doi">10.1016/j.cag.2010.04.003</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Technical Section</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Hybrid visibility compositing and masking for illustrative rendering<sup><xref ref-type="fn" rid="d30e189">☆</xref></sup></article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Bruckner</surname>
            <given-names>Stefan</given-names>
          </name>
          <email>bruckner@cg.tuwien.ac.at</email>
          <xref rid="aff1" ref-type="aff">a</xref>
          <xref rid="cor1" ref-type="corresp">⁎</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Rautek</surname>
            <given-names>Peter</given-names>
          </name>
          <xref rid="aff1" ref-type="aff">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Viola</surname>
            <given-names>Ivan</given-names>
          </name>
          <xref rid="aff2" ref-type="aff">b</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Roberts</surname>
            <given-names>Mike</given-names>
          </name>
          <xref rid="aff3" ref-type="aff">c</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Sousa</surname>
            <given-names>Mario Costa</given-names>
          </name>
          <xref rid="aff3" ref-type="aff">c</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Gröller</surname>
            <given-names>M. Eduard</given-names>
          </name>
          <xref rid="aff1" ref-type="aff">a</xref>
        </contrib>
      </contrib-group>
      <aff id="aff1"><label>a</label>Institute of Computer Graphics and Algorithms, Vienna University of Technology, Austria</aff>
      <aff id="aff2"><label>b</label>Department of Informatics, University of Bergen, Norway</aff>
      <aff id="aff3"><label>c</label>Department of Computer Science, University of Calgary, Canada</aff>
      <author-notes>
        <corresp id="cor1"><label>⁎</label>Corresponding author. Tel.: +43 1 58801 18643; fax: +43 1 58801 18698. <email>bruckner@cg.tuwien.ac.at</email></corresp>
      </author-notes>
      <pub-date pub-type="pmc-release">
        <month>8</month>
        <year>2010</year>
      </pub-date>
      <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="ppub"/>. -->
      <pub-date pub-type="ppub">
        <month>8</month>
        <year>2010</year>
      </pub-date>
      <volume>34</volume>
      <issue>4</issue>
      <fpage>361</fpage>
      <lpage>369</lpage>
      <permissions>
        <copyright-statement>© 2010 Elsevier Ltd.</copyright-statement>
        <copyright-year>2010</copyright-year>
        <copyright-holder>Elsevier Ltd</copyright-holder>
        <license>
          <license-p>This document may be redistributed and reused, subject to <ext-link ext-link-type="uri" xlink:href="http://www.elsevier.com/wps/find/authorsview.authors/supplementalterms1.0">certain conditions</ext-link>.</license-p>
        </license>
      </permissions>
      <abstract>
        <p>In this paper, we introduce a novel framework for the compositing of interactively rendered 3D layers tailored to the needs of scientific illustration. Currently, traditional scientific illustrations are produced in a series of composition stages, combining different pictorial elements using 2D digital layering. Our approach extends the layer metaphor into 3D without giving up the advantages of 2D methods. The new compositing approach allows for effects such as selective transparency, occlusion overrides, and soft depth buffering. Furthermore, we show how common manipulation techniques such as masking can be integrated into this concept. These tools behave just like in 2D, but their influence extends beyond a single viewpoint. Since the presented approach makes no assumptions about the underlying rendering algorithms, layers can be generated based on polygonal geometry, volumetric data, point-based representations, or others. Our implementation exploits current graphics hardware and permits real-time interaction and rendering.</p>
      </abstract>
      <kwd-group>
        <title>Keywords</title>
        <kwd>Compositing</kwd>
        <kwd>Masking</kwd>
        <kwd>Illustration</kwd>
      </kwd-group>
    </article-meta>
  </front>
  <body>
    <sec id="sec1">
      <label>1</label>
      <title>Introduction</title>
      <p>Digital compositing was arguably one of computer graphics’ first mainstream commercial applications. Areas such as motion picture post-production greatly benefited from automated processing. The ability to flexibly combine multiple sources ultimately lead to the widespread adoption of digital special effects which are now ubiquitous in the film industry. Today, virtually every image editing software package has the ability to arrange elements in layers, modify alpha channels, control blending, and apply effects to individual layers.</p>
      <p>In this paper, we focus on the compositing of dynamic 3D content. Instead of combining static elements such as images, movie sequences, or pre-rendered 3D animations, an interactive environment allows the modification of properties such as the viewpoint for individual layers which are rendered on-the-fly. Common software tools such as Adobe Photoshop have recently introduced the ability to embed dynamically generated layers based on 3D models. However, for the purpose of composing, the layer content is still treated as a 2D image even though additional information would be available. One reason for this choice is the fact that the conventional layered compositing approach, which assumes 2D layers, is deeply incorporated into these software packages and the workflow of their users. In this paper, we present a concept for the integration of 3D layers which preserves this intuitive notion, but allows artists to take advantage of 3D information by extending the operator set of traditional compositing approaches. We deliberately make minimal assumptions about the algorithms and data structures used to generate layer content to facilitate non-invasive integration into conventional image manipulation software.</p>
      <p>One of our target applications is the generation of technical, medical, and scientific illustrations which frequently make use of selective occlusion overrides and blending in order to produce an expressive image. Using our approach, an illustrator can modify 3D properties of the content layers without having to go through the entire compositing process again. However, the presented approach is general and not restricted to this particular scenario. While recent work in illustrative visualization has put special emphasis on the role of methods employed by graphics artists and illustrators, many approaches are limited to specific types of scientific data (e.g., scalar volume data) and/or application domains. Although our approach can handle dynamically changing 3D layers, it does not require knowledge about the underlying rendering algorithms. This enables the flexible integration of different data representations such as polygonal meshes, volumetric-, and point-based data as well as different rendering algorithms such as painterly, photorealistic, or illustrative rendering.</p>
      <p>The remainder of this paper is structured as follows: <xref rid="sec2" ref-type="sec">Section 2</xref> reviews related work. In <xref rid="sec3" ref-type="sec">Section 3</xref>, we discuss the concepts behind our hybrid visibility compositing approach. <xref rid="sec9" ref-type="sec">Section 4</xref> presents a technique for masking of dynamic 3D layers. <xref rid="sec10" ref-type="sec">Section 5</xref> details our implementation and <xref rid="sec11" ref-type="sec">Section 6</xref> presents further results. We discuss our approach in <xref rid="sec12" ref-type="sec">Section 7</xref> and conclude the paper in <xref rid="sec13" ref-type="sec">Section 8</xref>.</p>
    </sec>
    <sec id="sec2">
      <label>2</label>
      <title>Related work</title>
      <p>The work presented in this paper is related to several fields. Our approach is based on the large body of research in the area of digital compositing. Masking of 3D layers is related to image-based rendering techniques which attempt to generate novel views of 3D objects based on partial information. Furthermore, we were also inspired by illustrative and non-photorealistic rendering techniques which aim to reproduce the aesthetic quality of manually generated artwork using computer graphics.</p>
      <p><italic>Digital compositing</italic>: Digital compositing dates back to the early days of computer graphics as a scientific discipline. Alvy Ray Smith and Ed Catmull combined two images using a third image of coverage values which subsequently lead to the notion of the alpha channel <xref rid="bib1" ref-type="bibr">[1]</xref>. Wallace <xref rid="bib2" ref-type="bibr">[2]</xref> extended the approach to recursive blending allowing layers to be composited in any order that obeys associativity. Porter and Duff <xref rid="bib3" ref-type="bibr">[3]</xref> introduced the concept of pre-multiplied alpha and formulated the compositing algebra which is in widespread use today. For the purpose of anti-aliased combination of 3D rendering results, Duff <xref rid="bib4" ref-type="bibr">[4]</xref> proposed the <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M1" altimg="si0010.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> representation which, in addition to color and alpha channels, also includes a depth value for every pixel. Recent work by McCann and Pollard <xref rid="bib5" ref-type="bibr">[5]</xref> extends the flexibility of traditional compositing by enabling stacking decisions on a per-overlap basis. However, their approach is designed to provide more control over the compositing of 2D layers, while the concept presented in this paper aims at facilitating the integration of 3D content in a consistent manner.</p>
      <p><italic>Image-based rendering</italic>: The idea of avoiding expensive rendering passes by using compositing to combine parts of a scene gave rise to the area of image-based rendering. Image-based rendering approaches attempt to synthesize novel views which closely approximate correct visibility from information captured during the generation of a single image. Lengyel and Snyder <xref rid="bib6" ref-type="bibr">[6]</xref> proposed a factorization of 3D scenes into independent 2D sprites which could have different update rates. While their approach attempts to identify independent 2D layers, our method makes use of the available depth information and therefore allows full control over intersecting objects. Nailboards additionally store a depth value for every pixel of a sprite to enable the rendering of interpenetrating 3D objects with correct visibility <xref rid="bib7" ref-type="bibr">[7]</xref>. Layered depth images contain multiple pixels along each line of sight to enable the generation of novel views with higher fidelity <xref rid="bib8" ref-type="bibr">[8]</xref>. These approaches use layers with additional spatial information to combine parts of a scene with correct visibility. However, the focus of our work is different: we want to provide the user with the ability to selectively override occlusion relationships as it is common in technical, medical, and scientific illustrations.</p>
      <p><italic>Illustrative rendering</italic>: Several systems for the generation of illustrations using computer graphics have been developed. Dooley and Cohen <xref rid="bib9 bib10" ref-type="bibr">[9,10]</xref> presented approaches for the automatic generation of semi-transparent line and surface illustrations from 3D models. Pioneering work by Seligman and Feiner <xref rid="bib11 bib12 bib13" ref-type="bibr">[11–13]</xref> first treated the topic of visibility constraints. Their work employed cutaways and ghosting to resolve visibility conflicts. Preim et al. <xref rid="bib14" ref-type="bibr">[14]</xref> presented Zoom Illustrator, a semi-interactive tool for illustrating anatomic models. Their approach focuses on the integration of three-dimensional graphics and textual representations. Diepstraten et al. <xref rid="bib15 bib16" ref-type="bibr">[15,16]</xref> proposed rendering algorithms for ghosting and cutaway effects. Owada et al. <xref rid="bib17 bib18" ref-type="bibr">[17,18]</xref> developed a system for modeling and illustrating volumetric objects. They semi-automatically generate artificial cutting textures based on surface models. Viola et al. <xref rid="bib19" ref-type="bibr">[19]</xref> introduced the notion of importance-based rendering for improved visualization of features in volume data. Extending this approach, Bruckner and Gröller <xref rid="bib20" ref-type="bibr">[20]</xref> presented a flexible interactive direct volume illustration system. Rautek et al. <xref rid="bib21 bib22" ref-type="bibr">[21,22]</xref> proposed the use of semantic layers defined using a fuzzy logic rule base. Cole et al. <xref rid="bib23" ref-type="bibr">[23]</xref> proposed a technique for generating architectural illustrations featuring a stylized focus area through local variations in shading effects and line qualities. Kalkofen et al. <xref rid="bib24" ref-type="bibr">[24]</xref> used stylized overlays for focus+context visualization in augmented reality applications. Li et al. <xref rid="bib25 bib26" ref-type="bibr">[25,26]</xref> presented geometric methods for generating high-quality cutaway and exploded view diagrams. Raman et al. <xref rid="bib27" ref-type="bibr">[27]</xref> discussed a system which uses layer-based effects to enhance the visualization of volume data. Similar to our approach, the ClearView system presented by Krüger et al. <xref rid="bib28" ref-type="bibr">[28]</xref> uses layered rendering to generate a number of different transparency effects inspired by traditional illustrations. However, their approach relies on a globally defined layer order, for instance nested isosurfaces of a volume dataset. Furthermore, their method only allows the use of a single spherical focus region.</p>
      <p>In this paper we contribute with a new approach to combining interactively rendered 3D output based on the communication goals and stylization requirements of technical, medical and scientific illustrations. We introduce the notion of hybrid visibility compositing which allows integration of layered 2D compositing with 3D visibility operations in a flexible and intuitive manner. Additionally, we propose a new method for performing common masking operations based on this concept. The resulting framework enables the interactive generation of 3D illustrations featuring effects and techniques typically only available in 2D compositing software.</p>
    </sec>
    <sec id="sec3">
      <label>3</label>
      <title>Compositing</title>
      <p>Duff <xref rid="bib4" ref-type="bibr">[4]</xref> was the first to propose the <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M2" altimg="si0011.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> representation for compositing 3D rendered images. In such a representation each pixel stores, in addition to its color and alpha value, a depth value. In a way, such an <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M3" altimg="si0012.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> image is a generalization of a 2D sprite <xref rid="bib29" ref-type="bibr">[29]</xref>—points with color, transparency, and depth, but without any thickness information. Even though <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M4" altimg="si0013.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> layers are not a complete description of a general 3D object, they are a useful extension of conventional 2D layers. One of the main reasons why we choose this representation is that it requires minimal information about the actual data structures and algorithms used to provide layer content. A layer may be generated through ray tracing, rasterization of polygonal models, point-based rendering, or virtually any other technique capable of producing color and depth information.</p>
      <p>We therefore choose this representation as one of the basic building blocks of our compositing framework. Each 3D layer is bound to a renderer instance and captures its output as an <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M5" altimg="si0014.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> image at any time. The content of such a layer may change dynamically, e.g., due to user interaction or animation. The compositing engine then decides how these layers are combined to form the final image. Since current graphics hardware allows us to easily access its color and depth buffers, one advantage of employing an <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M6" altimg="si0015.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> representation is that no modifications to the rendering stage are required. This means that the compositing engine can be used to combine layers produced by a variety of different rendering algorithms.</p>
      <sec id="sec4">
        <label>3.1</label>
        <title>Implicit visibility</title>
        <p>In contrast to 2D compositing where the stacking order of layers is solely specified by the user, <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M7" altimg="si0016.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> layers have an <italic>implicit visibility</italic> defined by the relative depth values of their pixels. The general technique for compositing multiple <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M8" altimg="si0017.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> layers with correct visibility is through a per-pixel application of the painter's algorithm: for each pixel, the corresponding depth values of all layers are sorted and then blended together using the <italic>over</italic> operator, i.e., each layer overdraws the layers located behind to a degree specified by its alpha channel. While such a compositing algorithm permits the combination of many different rendering techniques, it does not provide the same level of flexibility as 2D compositing in which the user has full control over layer order and blending operators.</p>
      </sec>
      <sec id="sec5">
        <label>3.2</label>
        <title>Explicit visibility</title>
        <p>Another approach to compositing <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M9" altimg="si0018.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> layers is to employ <italic>explicit visibility</italic> by ignoring the per-pixel depth values and defining a stacking order in which blending operators are applied. This means that the layers are treated as flat images. Their operators are applied in the same order for all pixels. Employing explicit visibility for 3D content can be useful for creating illustrations when a particular layer should be emphasized by overlaying over layers depicting occluding structures. However, it also completely discards the additional information provided by the depth values.</p>
      </sec>
      <sec id="sec6">
        <label>3.3</label>
        <title>Hybrid visibility</title>
        <p>One of the main complications of implicit visibility compositing is that there is no consistent layer order. Using explicit visibility, layers can be moved in the stacking order to control which structures appear in front of each other and this relationship remains true for all pixels of an image. For implicit visibility, however, there is an inherent layer order which may be different for each pixel. Ignoring the depth information sacrifices all the advantages of 3D layers while relying on the implicit visibility severely limits the range of possible operations. In order to provide the user with a more intuitive interface based on familiar 2D compositing metaphors while preserving the ability to render with correct occlusion, we use a <italic>hybrid visibility</italic> approach which represents a flexible combination between implicit and explicit visibility.</p>
        <p>As illustrated in <xref rid="fig1" ref-type="fig">Fig. 1</xref>, our framework allows the user to specify a stacking order for the input layers and group them hierarchically. Just like in conventional 2D approaches, each layer and group can be assigned a blending operator. Additionally, an optional layer mask, discussed in detail in <xref rid="sec9" ref-type="sec">Section 4</xref>, can be specified. Compositing is performed by traversing the layer hierarchy starting with the bottommost layer and blending the layers using their associated operator. The depth value of an intermediate image pixel always corresponds to the last layer which makes a visible contribution to it. For the purpose of integrating hybrid visibility into this familiar setup we provide a special set of blending operators which take into account spatial relationships.</p>
        <p><xref rid="fig2" ref-type="fig">Fig. 2</xref> illustrates the advantages of hybrid visibility for the generation of illustrations. In the first row, a manually generated illustration of a sports car is depicted in the left column. The center column shows the implicit visibility of a similar 3D model. In the right column, four individual layers of the car (chassis, tires, interior, and details) are shown. The second row shows an example of explicit visibility using the following stacking order from bottom to top: chassis, tires, interior, details. Even though a result similar to the manual illustration can be generated by employing explicit visibility, it does not translate to other viewpoints. The third row depicts results generated using our hybrid visibility approach which allows us to closely mimic the essential features of the manually generated image. Interior and tires form a <italic>visibility chain</italic> which uses implicit visibility. The result is combined with the chassis and the details using <italic>occlusion-based blending</italic>. These concepts are discussed in detail in the following sections.</p>
        <sec id="sec7">
          <label>3.3.1</label>
          <title>Visibility chains</title>
          <p>A visibility chain is simply a group of layers where, for each pixel, compositing is performed with implicit visibility. It is specified using the <italic>visibility</italic> operator. The chain starts with a layer that has its operator set to <italic>visibility</italic> and ends with the first subsequent layer in stacking order which uses a different operator—this layer terminates the chain. The compositing result of the visibility chain is combined with the intermediate image using the operator specified for the terminating layer. Compositing then proceeds normally with the next layer. The advantage of visibility chains is that they allow groups of layers to exhibit correct occlusion relationships among themselves while still being embedded in the specified layer hierarchy.</p>
          <p>For each pixel within a visibility chain, our algorithm first performs a depth sort of its input layers. Compositing is then performed by blending the individual layers in visibility order using the <italic>over</italic> operator. For additional control, we use a smooth distance-based weight similar to the blurred <italic>z</italic>-buffering approach proposed by Luft et al. <xref rid="bib30" ref-type="bibr">[30]</xref>. The color <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic></textual-form><mml:math id="M10" altimg="si0019.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi></mml:math></alternatives></inline-formula> used for compositing a layer <italic>L</italic><sub><italic>i</italic></sub> is a distance-weighted sum of the color of all layers in the visibility chain:<disp-formula id="fd1"><label>(1)</label><mml:math id="M11" altimg="si0020.gif" overflow="scroll"><mml:mtext>rgb</mml:mtext><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi>α</mml:mi><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>∑</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi>z</mml:mi><mml:mtext>,</mml:mtext><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi>z</mml:mi><mml:mtext>,</mml:mtext><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi mathvariant="italic">rgb</mml:mi><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>∑</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi>z</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi>z</mml:mi><mml:mtext>,</mml:mtext><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:mfrac></mml:math></disp-formula>Note that in Eq. <xref rid="fd1" ref-type="disp-formula">(1)</xref> each layer's color is pre-multiplied by its alpha value and that the result will also be an opacity-weighted color. The function <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>Δ</italic><italic>z</italic>(<italic>z</italic><sub>0</sub>, <italic>z</italic><sub>1</sub>, <italic>ω</italic>) ∈ [0, 1]</textual-form><mml:math id="M12" altimg="si0021.gif" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></alternatives></inline-formula> is a user-selectable function which controls the nature of the depth transition. We require the function to be monotonically increasing with the absolute difference between its first two arguments. The third argument <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ω</italic> ∈ [0, 1]</textual-form><mml:math id="M13" altimg="si0022.gif" overflow="scroll"><mml:mi>ω</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></alternatives></inline-formula> allows additional control over the particular shape of this function—increasing <italic>ω</italic> should lead to a sharper transition. Different types of such transition functions are possible, similar to easing curves in animation. In our current implementation, we use the following definition:<disp-formula id="fd2"><label>(2)</label><alternatives><textual-form specific-use="jats-markup"><italic>Δ</italic><italic>z</italic>(<italic>z</italic><sub>0</sub>,<italic>z</italic><sub>1</sub>,<italic>ω</italic>) = 1 − (smoothstep(<italic>ω</italic>,1,1 − |<italic>z</italic><sub>1</sub> − <italic>z</italic><sub>0</sub>|)) <sup><italic>ω</italic></sup></textual-form><mml:math id="M14" altimg="si0024.gif" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mtext>,</mml:mtext><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mtext>,</mml:mtext><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>smoothstep</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>ω</mml:mi><mml:mtext>,</mml:mtext><mml:mn>1</mml:mn><mml:mtext>,</mml:mtext><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mo> </mml:mo></mml:mrow><mml:mrow><mml:mi>ω</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></disp-formula>where smoothstep (<italic>a</italic>,<italic>b</italic>,<italic>x</italic>) is OpenGL's smoothstep function typically implemented as <italic>u</italic><sup>2</sup>(3−2<italic>u</italic>) with <italic>u</italic> = clamp(0,1,(<italic>x</italic>−<italic>a</italic>)/(<italic>b</italic>−<italic>a</italic>)).</p>
          <p>If <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ω</italic> = 0</textual-form><mml:math id="M15" altimg="si0025.gif" overflow="scroll"><mml:mi>ω</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></alternatives></inline-formula>, the value of <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>Δ</italic><italic>z</italic></textual-form><mml:math id="M16" altimg="si0026.gif" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi></mml:math></alternatives></inline-formula> is always zero. For <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ω</italic> = 1</textual-form><mml:math id="M17" altimg="si0027.gif" overflow="scroll"><mml:mi>ω</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math></alternatives></inline-formula>, the function value is zero only if <italic>z</italic><sub>0</sub> = <italic>z</italic><sub>1</sub> and one otherwise. <xref rid="fig3" ref-type="fig">Fig. 3</xref> depicts graphs of the <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>Δ</italic><italic>z</italic></textual-form><mml:math id="M18" altimg="si0028.gif" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi></mml:math></alternatives></inline-formula>-function for different values of <italic>ω</italic>.</p>
          <p>If a pixel has the same depth in two layers, the resulting color will be the opacity-weighted average of the two layers’ colors. Conversely, if the depth of the pixel in both layers is sufficiently different, their influence on each other will be zero. The user can control the distance weighting for each layer in a visibility chain by modifying its <italic>ω</italic> parameter. The approach can be used to effectively combat <italic>z</italic>-fighting, but it also offers an additional degree of artistic freedom. For instance, the weight may be altered on a per-layer basis to give a better indication of spatial relationships or to suggest the softness of a particular object. <xref rid="fig4" ref-type="fig">Fig. 4</xref> shows an example. The teapot's body, handle, lid, and spout are rendered into separate layers and <italic>ω</italic> is globally set to 1, 0.5, 0.25, and 0.</p>
        </sec>
        <sec id="sec8">
          <label>3.3.2</label>
          <title>Occlusion-based blending</title>
          <p>In addition to the <italic>visibility</italic> operator, we provide a simple but powerful extension of conventional blending operators which allows them to make use of the additional spatial information. This includes the operators of the Porter–Duff algebra, such as <italic>over</italic>, <italic>atop</italic>, <italic>in</italic>, and <italic>out</italic>, as well as further operators typically present in image manipulation software (e.g., <italic>multiply</italic>, <italic>screen</italic>, or <italic>overlay</italic>). Our framework allows the use of all these operators in combination with a blending weight based on the distance between the layer's depth <italic>z</italic> and the current depth of the intermediate composite <italic>z</italic><sub><italic>f</italic></sub>. The layer's opacity is multiplied by the blending weight <italic>w</italic><sub><italic>o</italic></sub> which is computed by<disp-formula id="fd3"><label>(3)</label><mml:math id="M19" altimg="si0032.gif" overflow="scroll"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="{"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mn>1</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mtext>if</mml:mtext><mml:mspace width="0.33em"/><mml:mi>β</mml:mi><mml:mi>z</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>β</mml:mi><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>f</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mtext>,</mml:mtext><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>f</mml:mi></mml:mrow></mml:msub><mml:mtext>,</mml:mtext><mml:mo>|</mml:mo><mml:mi>β</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math></disp-formula>where <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>β</italic> ∈ [ − 1, 1]</textual-form><mml:math id="M20" altimg="si0033.gif" overflow="scroll"><mml:mi>β</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></alternatives></inline-formula> is a user-controlled parameter of the operator. If <italic>β</italic> is zero (the default value), the operator will behave exactly like its two-dimensional counterpart. If <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>β</italic> &gt; 0</textual-form><mml:math id="M21" altimg="si0035.gif" overflow="scroll"><mml:mi>β</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></alternatives></inline-formula>, the parts in front of the intermediate image will be shown and parts behind it will decrease in opacity with increasing distance. Conversely, if <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>β</italic> &lt; 0</textual-form><mml:math id="M22" altimg="si0036.gif" overflow="scroll"><mml:mi>β</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>0</mml:mn></mml:math></alternatives></inline-formula> parts behind the current depth of the intermediate composite will be shown with full opacity and parts in front of it will decrease in opacity with increasing distance. This enables smooth fading of layers based on occlusion relationships. For instance, two layers containing different representations of the same object can be used to make it shine through an occluding layer with a different appearance. This effect is demonstrated in <xref rid="fig10" ref-type="fig">Fig. 10</xref> where an occlusion-based <italic>plus</italic> operator is used to show an X-ray style representation of the hand where it is occluded by the lens of the magnifying glass.</p>
        </sec>
      </sec>
    </sec>
    <sec id="sec9">
      <label>4</label>
      <title>Masking</title>
      <p>A common technique frequently employed for the compositing of 2D images is masking. A layer mask enables the artist to modify visibility independent of layer content. It can be utilized to make structures semi-transparent using smooth transitions, give selective emphasis to certain objects, or to remove unwanted parts. Common software packages feature flexible brushing tools to perform these manipulations (e.g., Adobe Photoshop's eraser).</p>
      <p>When dealing with 3D layers which are generated on-the-fly and allow interactive modification of the viewpoint, however, the extension of such tools is not straight-forward. A purely 2D approach would be invariant to any camera changes and therefore frequently lead to undesired results when the viewpoint is modified. When we attempt to operate in object-space, on the other hand, we face the problem that a <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M23" altimg="si0037.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> layer is not a complete representation of a 3D object. The only 3D information available is the first visible surface of the object for the current viewpoint. While the renderer has complete information about the structure of the object, leaving the task of masking to each renderer would be prone to much duplication and potential inconsistencies as well as requiring modification of each rendering algorithm. For instance, a layer generated using volume rendering would need to handle masking operations in an entirely different manner than a layer generated by rendering polygonal geometry.</p>
      <p>Our approach for masking represents a hybrid image-space/object-space approach which does not require additional information other than that provided by <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M24" altimg="si0038.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> layers. It can therefore be used for any kind of layer, irrespective of layer content. The user simply selects the target layer for the masking operation and can then paint on it to establish the mask. As soon as a stroke is placed by brushing over an area, the depth value of the layer is read. Together with the image-space position this gives us the 3D location of the stroke under the current viewing transformation. Applying the inverse viewing transformation transforms the stroke location into object space. This position, together with the current brush settings, is stored in a list associated with the selected layer. Whenever a layer has been updated by the corresponding renderer (e.g., due to a change of the viewing transformation) the list of strokes for the layer is traversed and rendered using splatting <xref rid="bib31" ref-type="bibr">[31]</xref>. Each stroke is rasterized as a view-aligned impostor under the current viewing transformation. For each fragment of the stroke, we now have its intensity <italic>i</italic> and depth <italic>z</italic>. The intensity <italic>i</italic> is determined by the brush parameters and can be, for example, a 2D Gaussian with its peak centered at the stroke's image-space position. The depth <italic>z</italic> is simply the depth of the impostor fragment.</p>
      <p>Then, for each fragment of the stroke, the depth <italic>z</italic><sub><italic>l</italic></sub> of the layer at the fragment's position is read. As this value is the first intersection of the viewing ray with the three-dimensional object represented by the layer, we can use it to estimate how much influence this fragment of the stroke should have for the current viewpoint. For instance, if the surface point we originally placed our stroke on is now occluded by another part of the surface, the difference between <italic>z</italic> and <italic>z</italic><sub><italic>l</italic></sub> will be high. Conversely, if the same point on the surface we placed the stroke on is still visible in the novel viewpoint, the difference will be zero at that location. <xref rid="fig5" ref-type="fig">Fig. 5</xref> illustrates this behavior. It depicts two stroke centers rendered from two different viewpoints. From view 1, both stroke centers lie on the surface, i.e., <italic>z</italic>=<italic>z</italic><sub><italic>l</italic></sub>. For view 2, stroke 2 still lies on the visible surface. The position of stroke 1, however, is occluded by another part of the object, i.e., the difference between <italic>z</italic> and <italic>z</italic><sub><italic>l</italic></sub> is large.</p>
      <p>As we want our strokes to vary smoothly in intensity when the view is changed, we choose to modulate the stroke intensity <italic>i</italic> using a weight <italic>w</italic><sub><italic>b</italic></sub> based on the difference between <italic>z</italic> and <italic>z</italic><sub><italic>l</italic></sub>. This weight is computed using the previously discussed <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>Δ</italic><italic>z</italic></textual-form><mml:math id="M25" altimg="si0039.gif" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi></mml:math></alternatives></inline-formula>-function:<disp-formula id="fd4"><label>(4)</label><alternatives><textual-form specific-use="jats-markup"><italic>w</italic><sub><italic>b</italic></sub> = 1 − <italic>Δ</italic><italic>z</italic>(<italic>z</italic>,<italic>z</italic><sub><italic>l</italic></sub>,<italic>γ</italic>)</textual-form><mml:math id="M26" altimg="si0040.gif" overflow="scroll"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mtext>,</mml:mtext><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mtext>,</mml:mtext><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></alternatives></disp-formula>where <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>γ</italic> ∈ [0, 1]</textual-form><mml:math id="M27" altimg="si0041.gif" overflow="scroll"><mml:mi>γ</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></alternatives></inline-formula> is a user-controlled parameter of the brush. An intuitive feature of this approach is that the brush is sensitive to the properties of the visible surface. If a large brush is chosen the rendered imposter will be a large flat disc centered at the stroke position. As the distance between the disc's depth and the surface depth modifies the brush intensity, depth discontinuities will tend to be preserved. Since we store brush strokes using a point-based representation there are other advantages of our approach: as the brush strokes are rasterized for every novel view, aliasing is avoided. Furthermore, parameters such as brush intensity, size, or shape can be modified after the strokes have been placed.</p>
      <p>Typically, the masking channel is used to modulate layer opacity, i.e., it is multiplied with the <italic>α</italic> value of the corresponding layer pixel. To enable further control over the effect of masking, we provide an additional parameter <italic>s</italic> in the range [−1,1] which the user can modify independently for each layer. If <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>s</italic> ≥ 0</textual-form><mml:math id="M28" altimg="si0043.gif" overflow="scroll"><mml:mi>s</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:math></alternatives></inline-formula>, the <italic>α</italic> value for each pixel is additionally multiplied by 1−<italic>si</italic>, where <italic>i</italic> is the brushed intensity for the layer pixel. If <italic>s</italic> is negative, <italic>α</italic> is multiplied by 1−<italic>si</italic>+<italic>s</italic>. If <italic>s</italic> is positive, the layer becomes more transparent with higher brush intensity. Negative values of <italic>s</italic> invert the effect: the layer is transparent where the brush intensity is zero and becomes more opaque with increasing values. Setting <italic>s</italic> to zero disables any effect of masking.</p>
    </sec>
    <sec id="sec10">
      <label>5</label>
      <title>Implementation</title>
      <p>The techniques described in this paper were implemented as an extension to an existing rendering framework written in C++ and OpenGL/GLSL. In order to make use of all available renderers of the framework, the basic display routine was modified to supply each renderer instance (which represents a layer) with an offscreen buffer for color and depth instead of the visible framebuffer. This is possible using the EXT_framebuffer_object OpenGL extension. For the renderers, this change was completely transparent—the rendering code did not require any changes. In fact, the framework now allows the compositing engine to be switched at runtime. The offscreen buffers are allocated as an array texture (an array of 2D textures which can be accessed similar to a 3D texture) provided by the EXT_texture_array extension. When a renderer instance needs to update itself, it simply renders a new image into its offscreen buffer–all other images are left unmodified. This also means that when a user interaction occurs, only those renderers which are affected by the change need to re-execute.</p>
      <p>The compositing algorithm then uses the current values stored in the array texture. It is executed for every frame. The significant improvements concerning conditionals and loops introduced by the latest generation of graphics hardware allowed us to implement the whole compositing algorithm in a single-pass fragment program. This fragment program first reads colors, depth values, and masking information for every layer. Completely transparent pixels can be culled during this early stage which serves as a great source for performance improvement as they do not have to be considered in the subsequent steps. Compositing is then performed corresponding to the specified stacking order and grouping hierarchy. For visibility chains, depth sorting is performed in the fragment program. An additional offscreen buffer is kept for each layer where masking has been applied. When the appropriate input event occurs, the current masking parameters together with the determined object-space stroke locations are stored in a list associated with the selected layer. Every time a renderer has updated itself, this information is used to execute the algorithm described in <xref rid="sec9" ref-type="sec">Section 4</xref>. For rendering the strokes as imposters, we employ OpenGL's ARB_point_sprite extension which allows for textured as well as analytically defined brush tips. One advantage of having the result of several renderers available as separate layers is that different effects can be applied selectively. Again, we draw inspiration from 2D image manipulation software which offers a wide variety of layer effects. As our layers also store depth information even more options are available. Our framework provides a flexible interface for integrating these effects. For example, we employ the depth-based image enhancement approach presented by Luft et al. <xref rid="bib32" ref-type="bibr">[32]</xref> which has proven to be a natural extension of common two-dimensional glow or drop shadow filters.</p>
      <p>Although the current implementation of our compositing algorithm was not optimized for performance, it performs at frame rates above 20 frames/s for up to eight layers with a window size of 800×600 pixels on a GeForce 8800 GTX GPU. The overall performance is heavily dependent on the algorithms and models used to generate the layer content. For all the results shown in this paper the frame rate was over 5 frames/s for re-rendering all layers and effects. As the modification of a layer mask only requires a re-execution of the compositing pass, it is independent of layer content.</p>
    </sec>
    <sec id="sec11">
      <label>6</label>
      <title>Results</title>
      <p>In order to evaluate the utility of the presented techniques, we consulted a professional medical illustrator with over 25 years of experience in the field. We attempted to recreate effects and techniques commonly found in scientific and technical illustrations using 3D models.</p>
      <p>The illustration shown in <xref rid="fig6" ref-type="fig">Fig. 6</xref>(a) depicts the female reproductive system. The purpose of the illustration was to clearly show internal reproductive organs while indicating their placement within the body. The illustrator used 2D renditions of the individual elements which were combined in Adobe Photoshop. First, the body contours were placed on the bottommost layer and a drop shadow was added to lift the image off the background. The pelvis was then added as a second layer, its opacity was lowered, and a drop shadow filter was applied. Additionally, a mask layer was added to preserve the contour of the body around the genital area. Reproductive organs were added as a third layer and a layer mask was employed to lower the opacity of the uterus as it passes behind the pelvis. Instead of completely masking out the structures behind the pubic symphysis, the artist chose to keep this area slightly visible while still indicating to the viewer that these regions are located behind the pelvis.</p>
      <p>Using our approach the process of creating a similar illustration, as shown in <xref rid="fig6" ref-type="fig">Fig. 6</xref>(b), is analogous. Given a suitable 3D model, the user assigns the respective objects to individual layers. The same three layers are used: body contours, pelvis, and internal reproductive organs. The opacity of the pelvis layer is adjusted and our masking tool is applied, just like in the 2D workflow. However, instead of manually specifying a mask to achieve the desired see-through effect for the internal structures, pelvis and reproductive organs simply form a visibility chain which is combined with the body layer using the <italic>over</italic> operator. This enables the generation of novel views without requiring any changes, as shown in <xref rid="fig6" ref-type="fig">Fig. 6</xref>(c). <xref rid="fig7" ref-type="fig">Fig. 7</xref> depicts a further example of how our approach allows the user to employ the same effects as in 2D illustrations (see <xref rid="fig7" ref-type="fig">Fig. 7</xref>(a) and (b)), but enables the easy generation of novel views with the same hybrid visibility order. Additional illustrations showing the same topic are therefore easily created, as demonstrated in <xref rid="fig7" ref-type="fig">Fig. 7</xref>(c).</p>
      <p>In <xref rid="fig8" ref-type="fig">Fig. 8</xref>(a), we show an example of a human heart model rendered as a line drawing. Then, in <xref rid="fig8" ref-type="fig">Fig. 8</xref>(b), a layer depicting the pericardium (heart muscle) is added. In <xref rid="fig8" ref-type="fig">Fig. 8</xref>(c), additional layers depicting arterial and venous system are enabled. As no visibility overrides are required, all heart layers form a visibility chain which terminates with the <italic>over</italic> operator. The <italic>ω</italic> parameter of the pericardium is adjusted to make the inner structures of the heart close to the surface shine through. Masking is then applied to the line drawing and vascular layers making them fade into the background. <xref rid="fig8" ref-type="fig">Fig. 8</xref>(d) demonstrates that the brushed mask smoothly translates to other viewpoints.</p>
      <p><xref rid="fig9" ref-type="fig">Fig. 9</xref> depicts an illustration of the human vascular system. There are five layers: background, skin, skeleton, arterial system, and venous system. The background layer resides at the bottom, the skin layer uses the <italic>over</italic> operator. Skeleton, arteries, and veins form a visibility chain. The vein layer terminates the chain using the <italic>over</italic> operator. Masking has been applied to make these layers smoothly fade into the skin. Additionally, the <italic>ω</italic> parameter of the skeleton layer has been adjusted to show blood vessels passing closely behind bones.</p>
      <p>The illustration depicted in <xref rid="fig10" ref-type="fig">Fig. 10</xref> demonstrates that our approach can also be used to easily generate interactive effects such as magic lenses. This setup contains two layers generated by volume rendering of a human hand CT dataset. The first one uses non-photorealistic isosurface rendering of the skin while the second one uses maximum intensity projection to achieve an X-ray effect. The magnifying glass model is split into two layers: lens and body. The X-ray layer resides in a separate layer group with the lens and uses the <italic>plus</italic> operator and a negative <italic>β</italic> parameter so only the parts of the layer located behind the lens are added. The result forms a visibility chain with skin and body which is combined with the background layer using the <italic>over</italic> operator.</p>
    </sec>
    <sec id="sec12">
      <label>7</label>
      <title>Discussion</title>
      <p>One goal of the work discussed in this paper was to provide a practical way of incorporating illustrative rendering techniques into the workflow of illustrators and artists. Many high-quality illustrative techniques have been presented in recent years. However, these methods frequently rely on particular data structures and algorithms which makes their integration into professional software tools difficult. While it is possible to generate many of the effects presented in this paper using specialized algorithms, our contribution is a general concept which allows seamless integration of 3D layers into 2D software. Traditional compositing tools see the increasing need to provide 3D integration. The demand for this kind of functionality is evidenced by its recent incorporation into widely popular applications such as Adobe Photoshop. However, in current implementations 3D layers behave as 2D images with respect to other layers—there is no way to make use of the visibility information between two 3D layers. Using our approach, this functionality could be greatly extended in a non-invasive manner while still covering the full range of 2D operations.</p>
      <p>In a 2D workflow, artists frequently employ manually drawn layer masks to emulate visibility information for the generation of see-through and ghosting effects. Visibility chains and occlusion-based blending have shown to be effective tools to reduce the number and complexity of manually specified layer masks by taking advantage of the existing spatial information. Based on the artist's intent, however, additional masking is still useful in many cases. Our hybrid image-space/object-space method for brushing layer masks closes this gap by also exploiting spatial information for this operation. During experiments we found that our masking approach is very similar in behavior to analogous tools in 2D applications. One has the impression to be manipulating an image, but masking information smoothly transfers to nearby viewpoints in a consistent manner. However, it is impossible to predict the intent of the user in all cases. For example, if a user paints on one side of a radially symmetric object, it might be desirable to automatically have the object appear transparent from all viewing directions along the axis of symmetry. As our system is completely interactive, these cases can be easily resolved by rotating the object and placing new strokes. Our general approach also allows easy integration of additional specialized tools for this purpose.</p>
      <p>We received positive feedback on the utility of our prototype implementation and the general concept of hybrid visibility for generating illustrations. As shown in the examples in <xref rid="sec11" ref-type="sec">Section 6</xref>, our approach is capable of closely mimicking the traditional 2D compositing workflow. The ability of being able to alter an existing illustration by modifying the viewpoint was greatly appreciated and, given the availability of suitable 3D models, considered to have a high potential of speeding up the production process. However, as our research prototype does not encompass the full range of functionality featured in standard software packages, only the integration of the proposed concepts into a commercial product is likely to facilitate widespread adoption.</p>
    </sec>
    <sec id="sec13">
      <label>8</label>
      <title>Conclusion</title>
      <p>In this paper we presented a simple concept for illustrative compositing of dynamic 3D layers in an interactive environment. Our approach enables a wide variety of different effects such as selective occlusion overrides commonly employed in the generation of scientific and technical illustrations. With our method these operations can be performed in 3D using an extension of the familiar layer metaphor. We also proposed a novel technique for masking of 3D layers. It enables the generation of opacity transitions which smoothly extend beyond a single viewpoint. The presented framework makes minimal assumptions about the underlying algorithms used for rendering the individual layers. By exploiting the performance of current graphics hardware, high-quality illustrations of 3D objects can be generated interactively.</p>
    </sec>
  </body>
  <back>
    <ref-list>
      <title>References</title>
      <ref id="bib1">
        <label>1</label>
        <mixed-citation publication-type="other">Smith AR. Alpha and the history of digital compositing. Technical Memo 7, Microsoft Corporation, Redmond, Washington.</mixed-citation>
      </ref>
      <ref id="bib2">
        <label>2</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Wallace</surname>
              <given-names>B.A.</given-names>
            </name>
          </person-group>
          <article-title>Merging and transformation of raster images for cartoon animation</article-title>
          <source>ACM Computer Graphics</source>
          <volume>15</volume>
          <issue>3</issue>
          <year>1981</year>
          <fpage>253</fpage>
          <lpage>262</lpage>
        </element-citation>
      </ref>
      <ref id="bib3">
        <label>3</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Porter</surname>
              <given-names>T.</given-names>
            </name>
            <name>
              <surname>Duff</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <article-title>Compositing digital images</article-title>
          <source>ACM Computer Graphics</source>
          <volume>18</volume>
          <issue>3</issue>
          <year>1984</year>
          <fpage>253</fpage>
          <lpage>259</lpage>
        </element-citation>
      </ref>
      <ref id="bib4">
        <label>4</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Duff</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <article-title>Compositing 3-D rendered images</article-title>
          <source>ACM Computer Graphics</source>
          <volume>19</volume>
          <issue>3</issue>
          <year>1985</year>
          <fpage>41</fpage>
          <lpage>44</lpage>
        </element-citation>
      </ref>
      <ref id="bib5">
        <label>5</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>McCann</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Pollard</surname>
              <given-names>N.S.</given-names>
            </name>
          </person-group>
          <article-title>Local layering</article-title>
          <source>ACM Transactions on Graphics</source>
          <volume>28</volume>
          <issue>3</issue>
          <year>2009</year>
          <fpage>1</fpage>
          <lpage>7</lpage>
        </element-citation>
      </ref>
      <ref id="bib6">
        <label>6</label>
        <mixed-citation publication-type="other">Lengyel J, Snyder J. Rendering with coherent layers. In: Proceedings of ACM SIGGRAPH ’97, 1997. p. 233–42.</mixed-citation>
      </ref>
      <ref id="bib7">
        <label>7</label>
        <mixed-citation publication-type="other">Schaufler G. Nailboards: a rendering primitive for image caching in dynamic scenes. In: Proceedings of the Eurographics Workshop on Rendering ’97, 1997. p. 151–62.</mixed-citation>
      </ref>
      <ref id="bib8">
        <label>8</label>
        <mixed-citation publication-type="other">Shade J, Gortler S, He L-W, Szeliski R. Layered depth images. In: Proceedings of ACM SIGGRAPH ’98, 1998. p. 231–42.</mixed-citation>
      </ref>
      <ref id="bib9">
        <label>9</label>
        <mixed-citation publication-type="other">Dooley D, Cohen MF. Automatic illustration of 3D geometric models: lines. In: Proceedings of the symposium on interactive 3D graphics ’90, 1990. p. 77–82.</mixed-citation>
      </ref>
      <ref id="bib10">
        <label>10</label>
        <mixed-citation publication-type="other">Dooley D, Cohen MF. Automatic illustration of 3D geometric models: surfaces. In: Proceedings of IEEE Visualization ’90, 1990. p. 307–14.</mixed-citation>
      </ref>
      <ref id="bib11">
        <label>11</label>
        <mixed-citation publication-type="other">Seligmann DD, Feiner SK. Automated generation of intent-based 3D illustrations. In: Proceedings of ACM SIGGRAPH ’91, 1991. p. 123–32.</mixed-citation>
      </ref>
      <ref id="bib12">
        <label>12</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Feiner</surname>
              <given-names>S.K.</given-names>
            </name>
            <name>
              <surname>Seligmann</surname>
              <given-names>D.D.</given-names>
            </name>
          </person-group>
          <article-title>Cutaways and ghosting: satisfying visibility constraints in dynamic 3D illustrations</article-title>
          <source>The Visual Computer</source>
          <volume>8</volume>
          <issue>5 &amp; 6</issue>
          <year>1992</year>
          <fpage>292</fpage>
          <lpage>302</lpage>
        </element-citation>
      </ref>
      <ref id="bib13">
        <label>13</label>
        <mixed-citation publication-type="other">Seligmann DD, Feiner SK. Supporting interactivity in automated 3D illustrations. In: Proceedings of the international conference on intelligent user interfaces ’93, 1993. p. 37–44.</mixed-citation>
      </ref>
      <ref id="bib14">
        <label>14</label>
        <mixed-citation publication-type="other">Preim B, Ritter A, Strothotte T. Illustrating anatomic models—a semi-interactive approach. In: Proceedings of the international conference on visualization in biomedical computing ’96, 1996. p. 23–32.</mixed-citation>
      </ref>
      <ref id="bib15">
        <label>15</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Diepstraten</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Weiskopf</surname>
              <given-names>D.</given-names>
            </name>
            <name>
              <surname>Ertl</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <article-title>Transparency in interactive technical illustrations</article-title>
          <source>Computer Graphics Forum</source>
          <volume>21</volume>
          <issue>3</issue>
          <year>2002</year>
          <fpage>317</fpage>
          <lpage>325</lpage>
        </element-citation>
      </ref>
      <ref id="bib16">
        <label>16</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Diepstraten</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Weiskopf</surname>
              <given-names>D.</given-names>
            </name>
            <name>
              <surname>Ertl</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <article-title>Interactive cutaway illustrations</article-title>
          <source>Computer Graphics Forum</source>
          <volume>22</volume>
          <issue>3</issue>
          <year>2002</year>
          <fpage>523</fpage>
          <lpage>532</lpage>
        </element-citation>
      </ref>
      <ref id="bib17">
        <label>17</label>
        <mixed-citation publication-type="other">Owada S, Nielsen F, Nakazawa K, Igarashi T. A sketching interface for modeling the internal structures of 3D shapes. In: Proceedings of the international symposium on smart graphics ’03, 2003. p. 49–57.</mixed-citation>
      </ref>
      <ref id="bib18">
        <label>18</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Owada</surname>
              <given-names>S.</given-names>
            </name>
            <name>
              <surname>Nielsen</surname>
              <given-names>F.</given-names>
            </name>
            <name>
              <surname>Okabe</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Igarashi</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <article-title>Volumetric illustration: designing 3D models with internal textures</article-title>
          <source>ACM Transactions on Graphics</source>
          <volume>23</volume>
          <issue>3</issue>
          <year>2004</year>
          <fpage>322</fpage>
          <lpage>328</lpage>
        </element-citation>
      </ref>
      <ref id="bib19">
        <label>19</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Viola</surname>
              <given-names>I.</given-names>
            </name>
            <name>
              <surname>Kanitsar</surname>
              <given-names>A.</given-names>
            </name>
            <name>
              <surname>Gröller</surname>
              <given-names>M.E.</given-names>
            </name>
          </person-group>
          <article-title>Importance-driven feature enhancement in volume visualization</article-title>
          <source>IEEE Transactions on Visualization and Computer Graphics</source>
          <volume>11</volume>
          <issue>4</issue>
          <year>2005</year>
          <fpage>408</fpage>
          <lpage>418</lpage>
          <pub-id pub-id-type="pmid">16138551</pub-id>
        </element-citation>
      </ref>
      <ref id="bib20">
        <label>20</label>
        <mixed-citation publication-type="other">Bruckner S, Gröller ME. VolumeShop: an interactive system for direct volume illustration. In: Proceedings of IEEE visualization ’05, 2005. p. 671–8.</mixed-citation>
      </ref>
      <ref id="bib21">
        <label>21</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Rautek</surname>
              <given-names>P.</given-names>
            </name>
            <name>
              <surname>Bruckner</surname>
              <given-names>S.</given-names>
            </name>
            <name>
              <surname>Gröller</surname>
              <given-names>M.E.</given-names>
            </name>
          </person-group>
          <article-title>Semantic layers for illustrative volume rendering</article-title>
          <source>IEEE Transactions on Visualization and Computer Graphics</source>
          <volume>13</volume>
          <issue>6</issue>
          <year>2007</year>
          <fpage>1336</fpage>
          <lpage>1343</lpage>
          <pub-id pub-id-type="pmid">17968082</pub-id>
        </element-citation>
      </ref>
      <ref id="bib22">
        <label>22</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Rautek</surname>
              <given-names>P.</given-names>
            </name>
            <name>
              <surname>Bruckner</surname>
              <given-names>S.</given-names>
            </name>
            <name>
              <surname>Gröller</surname>
              <given-names>M.E.</given-names>
            </name>
          </person-group>
          <article-title>Interaction-dependent semantics for illustrative volume rendering</article-title>
          <source>Computer Graphics Forum</source>
          <volume>27</volume>
          <issue>3</issue>
          <year>2008</year>
          <fpage>847</fpage>
          <lpage>854</lpage>
        </element-citation>
      </ref>
      <ref id="bib23">
        <label>23</label>
        <mixed-citation publication-type="other">Cole F, DeCarlo D, Finkelstein A, Kin K, Morley K, Santella A. Directing gaze in 3D models with stylized focus. In: Proceedings of the eurographics symposium on rendering ’06, 2006. p. 377–87.</mixed-citation>
      </ref>
      <ref id="bib24">
        <label>24</label>
        <mixed-citation publication-type="other">Kalkofen D, Mendez E, Schmalstieg D. Interactive focus and context visualization for augmented reality. In: Proceedings of the IEEE international symposium on mixed and augmented reality ’07, 2007. p. 1–10.</mixed-citation>
      </ref>
      <ref id="bib25">
        <label>25</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Li</surname>
              <given-names>W.</given-names>
            </name>
            <name>
              <surname>Ritter</surname>
              <given-names>L.</given-names>
            </name>
            <name>
              <surname>Agrawala</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Curless</surname>
              <given-names>B.</given-names>
            </name>
            <name>
              <surname>Salesin</surname>
              <given-names>D.</given-names>
            </name>
          </person-group>
          <article-title>Interactive cutaway illustrations of complex 3D models</article-title>
          <source>ACM Transactions on Graphics</source>
          <volume>26</volume>
          <issue>3</issue>
          <year>2007</year>
          <fpage>3:11</fpage>
          <lpage>31:11</lpage>
        </element-citation>
      </ref>
      <ref id="bib26">
        <label>26</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Li</surname>
              <given-names>W.</given-names>
            </name>
            <name>
              <surname>Agrawala</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Curless</surname>
              <given-names>B.</given-names>
            </name>
            <name>
              <surname>Salesin</surname>
              <given-names>D.</given-names>
            </name>
          </person-group>
          <article-title>Automated generation of interactive 3D exploded view diagrams</article-title>
          <source>ACM Transactions on Graphics</source>
          <volume>27</volume>
          <issue>3</issue>
          <year>2008</year>
          <fpage>1</fpage>
          <lpage>7</lpage>
        </element-citation>
      </ref>
      <ref id="bib27">
        <label>27</label>
        <mixed-citation publication-type="other">Raman S, Mishchenko O, Crawfis R. Layers for effective volume rendering. In: Proceedings of the international symposium on volume and point-based graphics ’08, 2008. p. 81–8.</mixed-citation>
      </ref>
      <ref id="bib28">
        <label>28</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Krüger</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Schneider</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Westermann</surname>
              <given-names>R.</given-names>
            </name>
          </person-group>
          <article-title>Clearview: an interactive context preserving hotspot visualization technique</article-title>
          <source>IEEE Transactions on Visualization and Computer Graphics</source>
          <volume>12</volume>
          <issue>5</issue>
          <year>2006</year>
          <fpage>941</fpage>
          <lpage>948</lpage>
          <pub-id pub-id-type="pmid">17080820</pub-id>
        </element-citation>
      </ref>
      <ref id="bib29">
        <label>29</label>
        <mixed-citation publication-type="other">Smith AR. A sprite theory of image computing. Technical Memo 5, Microsoft Corporation, Redmond, Washington.</mixed-citation>
      </ref>
      <ref id="bib30">
        <label>30</label>
        <mixed-citation publication-type="other">Luft T, Deussen O. Real-time watercolor illustrations of plants using a blurred depth test. In: Proceedings of the international symposium on non-photorealistic animation and rendering ’06, 2006. p. 11–20.</mixed-citation>
      </ref>
      <ref id="bib31">
        <label>31</label>
        <mixed-citation publication-type="other">Westover L. Footprint evaluation for volume rendering. In: Proceedings of ACM SIGGRAPH ’90, 1990. p. 367–76.</mixed-citation>
      </ref>
      <ref id="bib32">
        <label>32</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Luft</surname>
              <given-names>T.</given-names>
            </name>
            <name>
              <surname>Colditz</surname>
              <given-names>C.</given-names>
            </name>
            <name>
              <surname>Deussen</surname>
              <given-names>O.</given-names>
            </name>
          </person-group>
          <article-title>Image enhancement by unsharp masking the depth buffer</article-title>
          <source>ACM Transactions on Graphics</source>
          <volume>25</volume>
          <issue>3</issue>
          <year>2006</year>
          <fpage>1206</fpage>
          <lpage>1213</lpage>
        </element-citation>
      </ref>
    </ref-list>
    <sec id="sec14" sec-type="supplementary-material">
      <label>Appendix A</label>
      <title>Supplementary material</title>
      <p>
        <supplementary-material content-type="local-data" id="d30e1595">
          <caption>
            <title>Video 1</title>
          </caption>
          <media xlink:href="mmc1.avi" mimetype="video" mime-subtype="x-msvideo"/>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="d30e1600">
          <caption>
            <title>Video 2</title>
          </caption>
          <media xlink:href="mmc2.avi" mimetype="video" mime-subtype="x-msvideo"/>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="d30e1605">
          <caption>
            <title>Video 3</title>
          </caption>
          <media xlink:href="mmc3.avi" mimetype="video" mime-subtype="x-msvideo"/>
        </supplementary-material>
      </p>
    </sec>
    <ack>
      <title>Acknowledgments</title>
      <p>The work presented in this publication was supported by the Austrian Science Fund (FWF) Grant no. P21695—ViMaL: The Visualization Mapping Language, the Norwegian Research Council (Project no. 193170/S10) and by the MedViz Initiative in Bergen, as well as the iCORE/Foundation CMG Industrial Research Chair in Scalable Reservoir Visualization and the Discovery Grants Program from the Natural Sciences and Engineering Research Council of Canada.</p>
      <p>We want to thank CF Lietzau 3D Special (<ext-link ext-link-type="uri" xlink:href="http://www.anatomium.com">http://www.anatomium.com</ext-link>) for permission to use the P1 human anatomy model depicted in <xref rid="fig6 fig7 fig8 fig9" ref-type="fig">Figs. 6–9</xref>. Furthermore, we want to express our gratitude to Kari C. Toverud for providing her time and expertise.</p>
    </ack>
    <fn-group>
      <fn id="d30e189">
        <label>☆</label>
        <p>Funded by: FWF.</p>
      </fn>
    </fn-group>
  </back>
  <floats-group>
    <fig id="fig1">
      <label>Fig. 1</label>
      <caption>
        <p>Conceptual overview of our compositing setup. A layer definition is comprised of the layer content in form of an <inline-formula><alternatives><textual-form specific-use="jats-markup">rgb<italic>α</italic><italic>z</italic></textual-form><mml:math id="M29" altimg="si0001.gif" overflow="scroll"><mml:mi>rgb</mml:mi><mml:mi>α</mml:mi><mml:mi mathvariant="normal">z</mml:mi></mml:math></alternatives></inline-formula> image, an additional layer mask, and an associated blending operator. Layers are arranged in a hierarchical blending tree as exemplified in the figure: the upper highlighted layer in the stack consists of three sublayers and the lower highlighted layer consists of five sublayers one of which is itself composed of two sublayers.</p>
      </caption>
      <graphic xlink:href="gr1"/>
    </fig>
    <fig id="fig2">
      <label>Fig. 2</label>
      <caption>
        <p>Comparison of implicit, explicit, and hybrid visibility approaches to compositing. <italic>Top row</italic>: Left—manually generated illustration of a sports car. Center—implicit visibility of a similar 3D model. Right—four individual layers of the model. <italic>Middle row</italic>: Explicit visibility of the layers from three different viewpoints. <italic>Bottom row</italic>: Hybrid visibility of the layers from three different viewpoints. While implicit visibility alone does not capture the subtle effects used in the manual illustration, explicit visibility leads to distracting results when changing the viewpoint. Hybrid visibility avoids the drawbacks of both approaches. <italic>Manual illustration courtesy of</italic> ©<italic>Kevin Hulsey Illustration</italic>, <italic>Inc.</italic></p>
      </caption>
      <graphic xlink:href="gr2"/>
    </fig>
    <fig id="fig3">
      <label>Fig. 3</label>
      <caption>
        <p>Graphs of the <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>Δ</italic><italic>z</italic></textual-form><mml:math id="M30" altimg="si0002.gif" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>z</mml:mi></mml:math></alternatives></inline-formula>- function for different values of <italic>ω</italic>.</p>
      </caption>
      <graphic xlink:href="gr3"/>
    </fig>
    <fig id="fig4">
      <label>Fig. 4</label>
      <caption>
        <p>Soft depth compositing using different values for <italic>ω</italic>: (a) <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ω</italic> = 1</textual-form><mml:math id="M31" altimg="si0005.gif" overflow="scroll"><mml:mi>ω</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math></alternatives></inline-formula>; (b) <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ω</italic> = 0.5</textual-form><mml:math id="M32" altimg="si0006.gif" overflow="scroll"><mml:mi>ω</mml:mi><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:math></alternatives></inline-formula>; (c) <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ω</italic> = 0.25</textual-form><mml:math id="M33" altimg="si0007.gif" overflow="scroll"><mml:mi>ω</mml:mi><mml:mo>=</mml:mo><mml:mn>0.25</mml:mn></mml:math></alternatives></inline-formula>; and (d) <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ω</italic> = 0</textual-form><mml:math id="M34" altimg="si0008.gif" overflow="scroll"><mml:mi>ω</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></alternatives></inline-formula>.</p>
      </caption>
      <graphic xlink:href="gr4"/>
    </fig>
    <fig id="fig5">
      <label>Fig. 5</label>
      <caption>
        <p>Example of distance-based weighting for brush strokes. Two brush strokes (stroke 1, stroke 2) generated from the viewpoint view 1 are shown. In view 1, <italic>z</italic>=<italic>z</italic><sub><italic>l</italic></sub> for both strokes, i.e., both strokes receive the maximum weight. When a novel viewpoint (view 2) is chosen, stroke 1 has <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>z</italic> ≠ <italic>z</italic><sub><italic>l</italic></sub></textual-form><mml:math id="M35" altimg="si0009.gif" overflow="scroll"><mml:mi>z</mml:mi><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> due to occlusion, i.e., it receives a lower weight, while stroke 2 remains visible.</p>
      </caption>
      <graphic xlink:href="gr5"/>
    </fig>
    <fig id="fig6">
      <label>Fig. 6</label>
      <caption>
        <p>Female reproductive system: (a) 2D illustration generated using Adobe Photoshop; (b) 3D illustration generated using our compositing approach; and (c) different viewpoint of the 3D illustration. <italic>Illustrations courtesy of</italic> ©<italic>Kari C. Toverud, MS, CMI.</italic></p>
      </caption>
      <graphic xlink:href="gr6"/>
    </fig>
    <fig id="fig7">
      <label>Fig. 7</label>
      <caption>
        <p>Upper gastrointestinal tract: (a) 2D illustration generated using Adobe Photoshop; (b) 3D illustration generated using our compositing approach; and (c) different viewpoint of the 3D illustration. <italic>Illustrations courtesy of</italic> ©<italic>Kari C. Toverud, MS, CMI.</italic></p>
      </caption>
      <graphic xlink:href="gr7"/>
    </fig>
    <fig id="fig8">
      <label>Fig. 8</label>
      <caption>
        <p>Generation of a 3D illustration of the human heart: (a) line drawing layer; (b) combination with muscle layer; (c) applying masking; and (d) after rotation.</p>
      </caption>
      <graphic xlink:href="gr8"/>
    </fig>
    <fig id="fig9">
      <label>Fig. 9</label>
      <caption>
        <p>Interactively generated 3D illustration of the human vascular system.</p>
      </caption>
      <graphic xlink:href="gr9"/>
    </fig>
    <fig id="fig10">
      <label>Fig. 10</label>
      <caption>
        <p>Two viewpoints for a magic lens effect generated using our compositing framework.</p>
      </caption>
      <graphic xlink:href="gr10"/>
    </fig>
  </floats-group>
</article>