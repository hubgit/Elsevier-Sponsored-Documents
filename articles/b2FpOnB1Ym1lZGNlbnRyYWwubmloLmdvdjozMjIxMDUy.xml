<article xmlns="http://dtd.nlm.nih.gov/2.0/xsd/archivearticle" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://dtd.nlm.nih.gov/2.0/xsd/archivearticle http://dtd.nlm.nih.gov/2.0/xsd/archivearticle.xsd" article-type="brief-report">
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-ta">Neuroimage</journal-id>
      <journal-title-group>
        <journal-title>Neuroimage</journal-title>
      </journal-title-group>
      <issn pub-type="ppub">1053-8119</issn>
      <issn pub-type="epub">1095-9572</issn>
      <publisher>
        <publisher-name>Academic Press</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmc">3221052</article-id>
      <article-id pub-id-type="pmid">21216294</article-id>
      <article-id pub-id-type="publisher-id">YNIMG7923</article-id>
      <article-id pub-id-type="doi">10.1016/j.neuroimage.2010.12.049</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Technical Note</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Diffeomorphic registration using geodesic shooting and Gauss–Newton optimisation</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Ashburner</surname>
            <given-names>John</given-names>
          </name>
          <email>john@fil.ion.ucl.ac.uk</email>
          <xref rid="cr0005" ref-type="corresp">⁎</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Friston</surname>
            <given-names>Karl J.</given-names>
          </name>
        </contrib>
      </contrib-group>
      <aff id="af0005">Wellcome Trust Centre for Neuroimaging, UCL Institute of Neurology, London, UK</aff>
      <author-notes>
        <corresp id="cr0005"><label>⁎</label>Corresponding author. Wellcome Trust Centre for Neuroimaging, 12 Queen Square, London, WC1N 3BG, UK. Fax: + 44 20 78131420. <email>john@fil.ion.ucl.ac.uk</email></corresp>
      </author-notes>
      <pub-date pub-type="pmc-release">
        <day>01</day>
        <month>4</month>
        <year>2011</year>
      </pub-date>
      <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="ppub"/>. -->
      <pub-date pub-type="ppub">
        <day>01</day>
        <month>4</month>
        <year>2011</year>
      </pub-date>
      <volume>55</volume>
      <issue>3-3</issue>
      <fpage>954</fpage>
      <lpage>967</lpage>
      <history>
        <date date-type="received">
          <day>16</day>
          <month>7</month>
          <year>2010</year>
        </date>
        <date date-type="rev-recd">
          <day>8</day>
          <month>12</month>
          <year>2010</year>
        </date>
        <date date-type="accepted">
          <day>20</day>
          <month>12</month>
          <year>2010</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>© 2011 Elsevier Inc.</copyright-statement>
        <copyright-year>2011</copyright-year>
        <copyright-holder>Elsevier Inc.</copyright-holder>
        <license>
          <license-p>This document may be redistributed and reused, subject to <ext-link ext-link-type="uri" xlink:href="http://www.elsevier.com/wps/find/authorsview.authors/supplementalterms1.0">certain conditions</ext-link>.</license-p>
        </license>
      </permissions>
      <abstract>
        <p>This paper presents a nonlinear image registration algorithm based on the setting of <italic>Large Deformation Diffeomorphic Metric Mapping</italic> (LDDMM), but with a more efficient optimisation scheme — both in terms of memory required and the number of iterations required to reach convergence. Rather than perform a variational optimisation on a series of velocity fields, the algorithm is formulated to use a geodesic shooting procedure, so that only an initial velocity is estimated. A Gauss–Newton optimisation strategy is used to achieve faster convergence. The algorithm was evaluated using freely available manually labelled datasets, and found to compare favourably with other inter-subject registration algorithms evaluated using the same data.</p>
      </abstract>
      <kwd-group>
        <title>Keywords</title>
        <kwd>Diffeomorphisms</kwd>
        <kwd>Geodesic shooting</kwd>
        <kwd>Shape modelling</kwd>
        <kwd>Nonlinear registration</kwd>
        <kwd>Gauss–Newton optimisation</kwd>
      </kwd-group>
    </article-meta>
  </front>
  <body>
    <sec id="s0005">
      <title>Introduction</title>
      <p>This paper is about nonlinear image registration, which primarily aims to align images of different subjects, although it may also be of use for aligning longitudinal data of the same subject in situations where shape changes may have occurred. Inter-subject registration enables findings from functional imaging studies of different subjects to be brought within a common anatomical space, via a procedure known as “spatial normalisation”. In addition to this role, accurate alignment across subjects has many other applications, particularly in areas of translational science. Accurate registration allows information derived from some subjects (possibly from data that can only be collected post-mortem) to be generalised to the anatomy of other individuals.</p>
      <p>Unfortunately, it is commonplace to find neuroimagers still using relatively old and inaccurate inter-subject registration techniques (<xref rid="bb0100" ref-type="bibr">Klein et al., 2009</xref>), which preclude accurate localisation of findings from multiple subjects. This may be because of a commonly held belief that brain anatomy is not predictive of brain function. There is increasing evidence emerging that shows this argument to be incorrect, and that by aligning anatomical features, such as cortical folds, we are able to also align functionality homologous areas. Relatively recent advances show that information from anatomical scans (such as T1-weighted MRI) do allow the underlying cyto-architecture to be predicted from folding patterns of the cortex (<xref rid="bb0075 bb0150" ref-type="bibr">Fischl et al., 2008; Yeo et al., 2007</xref>). These studies were carried out by aligning cortical surfaces, and not by volumetric registration procedures. Evaluations based on manually traced structures show that nonlinear volumetric registration algorithms can be much more accurate than simple affine registration (<xref rid="bb0100" ref-type="bibr">Klein et al., 2009</xref>), although it still remains to be seen how well the most advanced volumetric registration methods can align cyto-architectonic borders. <xref rid="bb0105" ref-type="bibr">Klein et al. (2010)</xref> also showed that volumetric registration gave similar accuracy to cortical alignment approaches, although a more recent paper (<xref rid="bb0080" ref-type="bibr">Ghosh et al., 2010</xref>) showed higher accuracy for surface-based methods in some situations. The evaluations in the current paper will use some of the same dataset used by <xref rid="bb0100" ref-type="bibr">Klein et al. (2009)</xref>, and are based on an assumption that manually drawn labels are accurate enough to be used as “ground truth”. Any gains in accuracy should be of benefit in terms of achieving greater overlap of functionally specialised brain regions across subjects. In addition to improved regional specificity to whatever measure is of interest, more accurate alignment should also provide increased sensitivity, with less need to spatially blur images in order to superimpose features.</p>
      <p>Image registration models also play a useful role in geometric morphometrics, as registration essentially involves learning a model of the relative shapes of the organs or organisms under study. Shape, or form, may be encoded in numerous ways, some of which are more parsimonious than others. Under the assumption that measurements such as length, area and volume should all be positive, diffeomorphic registration approaches are able to encode relative shapes using the powerful <italic>initial momentum</italic> formulation (<xref rid="bb0145 bb0155" ref-type="bibr">Wang et al., 2007; Younes, 2007</xref>). The decreasing cost of gene sequencing, along with a trend to assemble large datasets of scans, is likely to lead to renewed interest in modelling inter-subject variability. As outlined in <xref rid="bb0040" ref-type="bibr">Ashburner and Klöppel (2010)</xref>, much of the inter-subject variance among brain images is dealt with by shape modelling (computational anatomy).</p>
      <p>Any conclusions drawn from a study depend on how the data are modelled. In the case of computational anatomy studies, the accuracy of inter-subject registration plays a significant role in terms of the actual findings obtained, as well as on the interpretability of those findings. It is therefore worth ensuring that an accurate and coherent model of the data is used, before attempting to draw a conclusion from the fitted model. From a theoretical perspective, the state-of-the-art in terms of formulating volumetric image registration, in a mathematically coherent way, is probably the <italic>Large Deformation Diffeomorphic Metric Mapping</italic> (LDDMM) of <xref rid="bb0050" ref-type="bibr">Beg et al. (2005)</xref>.</p>
      <p>Most image registration methods are based on a small-deformation approximation, which attempts to represent relative shapes in terms of displacement fields. Such models assume that displacements may be added and subtracted in a linear way, rather than by correctly composing deformations. Assumptions of linearity result in a number of problems (one-to-one mappings break down, lack of inverse consistency, etc), which are generally either ignored, or fixed using ad hoc procedures. The LDDMM framework resolves these limitations, at source, by using a more coherent formulation of the registration model. Instead of incorrectly assuming linearity, the formulation incorporates established techniques from the fields of differential geometry and mechanics.</p>
      <p>Another commonly used framework is the one known as “viscous-fluid modelling” (<xref rid="bb0065" ref-type="bibr">Christensen et al., 1996</xref>), which does not have a clearly defined objective function, thus precluding a probabilistic interpretation of the model. This is likely to limit its long term applicability.</p>
      <p>This paper builds on LDDMM, but includes some additional components that are intended to enable more efficient registration, both in terms of the number of iterations needed to achieve convergence and also the amount of memory required for encoding the deformations. Although over the longer term, processing speed will become much less important than accuracy, it is still worth trying to achieve equally accurate results as efficiently as possible.</p>
    </sec>
    <sec sec-type="methods" id="s0010">
      <title>Methods</title>
      <p>In the current work, image registration is treated as an optimisation problem, which involves minimising an objective function consisting of the sum of two terms.</p>
      <p>The first term is a measure of how much the template is distorted in order to match the individual's image. Because deformations do not add and subtract linearly, it is not optimal to measure the magnitude of a deformation based on some linear measure computed from a single displacement field. Such small-deformation approximation approaches are commonly used, but they do not give consistent measures of deformation magnitude between forward and inverse deformations. The magnitude of a deformation is better computed as a geodesic distance, using ∫ <sub><italic>t</italic> = 0</sub><sup>1</sup>||<bold>Lv</bold><sub><italic>t</italic></sub>||<italic>dt</italic>, where <bold>L</bold> is a linear operator, which operates on a time-dependent velocity that mediates the deformation over unit time. In practice, the registration is regularised by penalising the “energy” in the deformation (<inline-formula><mml:math id="M1" altimg="si1.gif" overflow="scroll"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mn>1</mml:mn></mml:msubsup><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mi mathvariant="bold">L</mml:mi><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula>), where <bold>L</bold> determines the nature of the energy (based on beliefs about what sorts of deformations are more probable <italic>a priori</italic>). Occasionally, the literature refers to velocities where each point in the time varying velocity field (<bold>v</bold><sub><italic>t</italic></sub>) is associated with the same point in the underlying image. This is not the case here, as <bold>v</bold><sub><italic>t</italic></sub> is the Eulerian speed vector field, defined over the ambient space through which the deforming image passes.</p>
      <p>The second term is a measure of how closely the images appear to be aligned, and is typically one of the usual cost functions used for image registration, such as the mean squared difference between a subject's image (<italic>f</italic>) and a deformed version of the template (<italic>μ</italic>(<italic>φ</italic><sub>1</sub><sup>− 1</sup>)). Here, <italic>φ</italic> is a diffeomorphic mapping (diffeomorphism) encoding the deformation. With this image matching term, the algorithm minimises the following:<disp-formula id="fo0005"><label>(1)</label><mml:math id="M2" altimg="si2.gif" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mn>1</mml:mn></mml:msubsup><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mi mathvariant="bold">L</mml:mi><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mi>f</mml:mi><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mfenced open="(" close=")"><mml:msubsup><mml:mi>φ</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mfenced><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mtext>,</mml:mtext><mml:mspace width="0.5em"/><mml:mtext>where</mml:mtext><mml:mspace width="0.5em"/><mml:msub><mml:mi>φ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mtext>Id</mml:mtext><mml:mtext>,</mml:mtext><mml:mspace width="0.5em"/><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mfenced open="(" close=")"><mml:msub><mml:mi>φ</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
      <p>Computing a diffeomorphic deformation is treated as modelling a dynamical system, which evolves over unit time. Subscripts on <bold>v</bold> and <italic>φ</italic> indicate velocity fields and diffeomorphisms at different time points. The easiest way to conceptualise the evolution is in terms of an Euler integration, in which case the diffeomorphism (<italic>φ</italic><sub>1</sub>) and its inverse (<italic>ϑ</italic><sub>1</sub>) are computed from the compositions of series of small-deformations. From this perspective, a series of <italic>N</italic> velocity fields are used to represent the time varying velocity field. For <italic>N</italic> uniformly spaced time steps (0, <italic>t</italic><sub>1</sub>, <italic>t</italic><sub>2</sub>,..., <italic>t</italic><sub><italic>N</italic> − 2</sub>, <italic>t</italic><sub><italic>N</italic> − 1</sub>), computing the diffeomorphisms may be achieved by:<disp-formula id="fo0010"><label>(2)</label><mml:math id="M3" altimg="si3.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:mo>...</mml:mo><mml:mo>∘</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula><disp-formula id="fo0015"><label>(3)</label><mml:math id="M4" altimg="si4.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi>ϑ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:mo>...</mml:mo><mml:mo>∘</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
      <p>Providing all the small-deformations are sufficiently small to be one-to-one (and satisfy certain smoothness criteria), their compositions should also result in one-to-one mappings (<xref rid="bb0060" ref-type="bibr">Christensen et al., 1995</xref>). More sophisticated integration methods (than Euler) yield more accurate results using fewer time steps, but are not explored here. It should also be pointed out that care should be taken with the compositions, particularly when interpolating deformation fields close to boundaries. In most situations, it is more efficient to use <inline-formula><mml:math id="M5" altimg="si5.gif" overflow="scroll"><mml:mrow><mml:mi>φ</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>∘</mml:mo><mml:mi>φ</mml:mi></mml:mrow></mml:math></inline-formula> instead of <inline-formula><mml:math id="M6" altimg="si6.gif" overflow="scroll"><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:mi>φ</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p><xref rid="bb0050" ref-type="bibr">Beg et al. (2005)</xref> describe registration in terms of a variational optimisation of this sequence of velocity fields, using a gradient descent scheme. This approach has two main disadvantages.<list list-type="simple"><list-item><label>1.</label><p>The entire sequence of velocity fields needs to be retained, either in memory or on disk, which can make the approach quite demanding in terms of memory requirements.</p></list-item><list-item><label>2.</label><p>Gradient descent optimisation is slow, and requires many iterations to reach satisfactory convergence.</p></list-item></list></p>
      <p>Instead of using a variational scheme to estimate a series of velocity fields, the aim of the optimisation in the current work is to determine only an initial velocity field (<bold>v</bold><sub>0</sub>). Forward and backward deformations (<italic>φ</italic> and <italic>ϑ</italic>) may then be computed from the initial velocity, using a <italic>geodesic shooting</italic> scheme. The use of GS negates the need to store the entire series of velocity fields, thus reducing memory and disk space requirements. The reason this works is that the principle of stationary action uniquely determines the trajectory of the deformation, given the initial velocity. Furthermore, because (kinetic) energy is conserved, we only need to evaluate the energy for this initial velocity. A related scheme has already been devised by <xref rid="bb0115" ref-type="bibr">Marsland and McLachlan (2007)</xref>, who parameterised two-dimensional deformations using 21 control points. Registration then involved estimating the 42 parameters that encode the initial momenta of these points. As pointed out by Marsland, his framework is too computationally expensive to use many control points and therefore not practical for the six million or so parameters that we use to represent relative shapes. A similar framework for optimising initial momentum was also presented in <xref rid="bb0070" ref-type="bibr">Cotter and Holm (2006)</xref>, but involved a particle mesh method that overcomes many of the computational problems of using control points. The work presented here shares a great deal with that in <xref rid="bb0070" ref-type="bibr">Cotter and Holm (2006)</xref> (neither requires the entire sequence of velocity fields to be stored), and is essentially a Gauss–Newton implementation of that approach.</p>
      <p>In the current work, registration is treated as a nonlinear optimisation problem, where the aim is to determine the optimal values for the coefficients parameterising a discretised version of the initial velocity field. Because it is nonlinear and has no closed-form solution, it requires an iterative approach to solve. We use a Gauss–Newton optimisation scheme, which uses approximations to both first and second derivatives and usually achieves convergence in fewer iterations than an approach using only first derivatives.</p>
      <p>The next section describes geodesic shooting, and this is followed by a section describing the optimisation scheme.</p>
      <sec id="s0015">
        <title>Geodesic shooting</title>
        <p>Beg's algorithm may be conceptualised within the framework of the <italic>principle of stationary action</italic>, which is a variational principle that may be used for obtaining equations of motion. Within this framework, <bold>L</bold><sup>†</sup><bold>L</bold> may be considered as a model of the “inertia” of the system, such that the “kinetic energy” of the evolving system is given by <inline-formula><alternatives><textual-form specific-use="jats-markup">½〈<bold>v</bold><sub><italic>t</italic></sub>, <bold>L</bold><sup>†</sup><bold>L</bold><bold>v</bold><sub><italic>t</italic></sub>〉</textual-form><mml:math id="M7" altimg="si7.gif" overflow="scroll"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mfenced open="〈" close="〉"><mml:mrow><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mi mathvariant="bold">L</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mi mathvariant="bold">L</mml:mi><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></alternatives></inline-formula>. Similarly, there is a concept of momentum, given by <bold>u</bold><sub><italic>t</italic></sub> = <bold>L</bold><sup>†</sup><bold>Lv</bold><sub><italic>t</italic></sub>. Velocity may be derived from momentum by smoothing with <bold>K</bold>, which is the inverse of the <bold>L</bold><sup>†</sup><bold>L</bold> operator. In other words, <bold>KL</bold><sup>†</sup><bold>Lv</bold> = <bold>v</bold> and <bold>L</bold><sup>†</sup><bold>LKu</bold> = <bold>u</bold>. Given an initial and final configuration (ie an identity transform and the final deformation respectively) at each iteration, Beg's algorithm determines the series of intermediate configurations that have the least kinetic energy. In practice it is a little more complicated than that, as the estimation of the final configuration is not really separated from the estimation of the intermediate configurations. The solution obtained by LDDMM satisfies the condition that the derivatives of the objective function with respect to changes in the velocity are zero. These derivatives were derived in <xref rid="bb0050" ref-type="bibr">Beg et al. (2005)</xref>, and a simpler derivation was also given in the appendix of <xref rid="bb0025" ref-type="bibr">Ashburner (2007)</xref>. This solution obeys the following <italic>Euler–Lagrange equation</italic> (Eq. (9) of <xref rid="bb0050" ref-type="bibr">Beg et al. (2005)</xref>), where the <bold>D</bold> operator refers to computing the Jacobian tensor:<disp-formula id="fo0020"><label>(4)</label><mml:math id="M8" altimg="si8.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi mathvariant="bold">K</mml:mi><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mi mathvariant="bold">D</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∘</mml:mo><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mo>∇</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>∘</mml:mo><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mi>f</mml:mi><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∘</mml:mo><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo>∘</mml:mo><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula></p>
        <p>The foregoing equation shows that, at the solution, the velocity at each time point may be derived from the initial velocity. The gradients of the warped template ∇ (<italic>μ</italic> ∘ <italic>φ</italic><sub><italic>t</italic></sub><sup>− 1</sup>) may also be computed by warping the gradients of the template and multiplying by the transpose of the Jacobian tensor at each point (<bold>D</bold><italic>φ</italic><sub><italic>t</italic></sub><sup>− 1</sup>)<sup><italic>T</italic></sup>((∇ <italic>μ</italic>) ∘ <italic>φ</italic><sub><italic>t</italic></sub><sup>− 1</sup>). Also, the Jacobian determinants of the composed transformations |<bold>D</bold>(<italic>φ</italic><sub>1</sub> ∘ <italic>φ</italic><sub><italic>t</italic></sub><sup>− 1</sup>)| may by computed by (|<bold>D</bold><italic>φ</italic><sub>1</sub>| ∘ <italic>φ</italic><sub><italic>t</italic></sub><sup>− 1</sup>)|<bold>D</bold><italic>φ</italic><sub><italic>t</italic></sub><sup>− 1</sup>|. This leads to the following re-arrangement of Eq. <xref rid="fo0020" ref-type="disp-formula">(4)</xref>:<disp-formula id="fo0025"><label>(5)</label><mml:math id="M9" altimg="si9.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="bold">K</mml:mi><mml:mfenced open="(" close=")"><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mi mathvariant="bold">D</mml:mi><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mi mathvariant="bold">D</mml:mi><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mfenced open="(" close=")"><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mi mathvariant="bold">D</mml:mi><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mo>∇</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>−</mml:mo><mml:mi>f</mml:mi><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfenced><mml:mi>∘</mml:mi><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
        <p>At time zero, <italic>φ</italic><sub>0</sub> is the identity transform, so the initial momentum is:<disp-formula id="fo0030"><label>(6)</label><alternatives><textual-form specific-use="jats-markup"><bold>u</bold><sub>0</sub> = <bold>L</bold><sup>†</sup><bold>L</bold><bold>v</bold><sub>0</sub> = ½|<bold>D</bold><italic>φ</italic><sub>1</sub>|(∇<italic>μ</italic>)(<italic>μ</italic> − <italic>f</italic> ∘ <italic>φ</italic><sub>1</sub>)</textual-form><mml:math id="M10" altimg="si10.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="bold">u</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="bold">L</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mi mathvariant="bold">L</mml:mi><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mi mathvariant="bold">D</mml:mi><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mo>∇</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>−</mml:mo><mml:mi>f</mml:mi><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>Combining Eqs. <xref rid="fo0025 fo0030" ref-type="disp-formula">(5) and (6)</xref> shows that the velocity at any time is given by the initial velocity or momentum:<disp-formula id="fo0035"><label>(7)</label><mml:math id="M11" altimg="si11.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="bold">K</mml:mi><mml:mfenced open="(" close=")"><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mi mathvariant="bold">D</mml:mi><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mi mathvariant="bold">D</mml:mi><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mi mathvariant="bold">u</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>∘</mml:mo><mml:msubsup><mml:mi>φ</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
        <p>This conservation of momentum is well known and leads to an alternative approach, which is to formulate each iteration of the registration as an initial value problem. Here, the intermediate configurations, and therefore the final deformation, are all computed from the initial conditions. These initial conditions are the spatial configuration (an identity transform) and the initial velocity or momentum. This procedure is known as <italic>geodesic shooting</italic> (GS), and may be viewed as an integration based on Hamilton's equations. More complete explanations of the mathematics underlying the GS approach are to be found in the literature (<xref rid="bb0120 bb0070 bb0115 bb0155 bb0165 bb0170" ref-type="bibr">Miller et al., 2006; Cotter and Holm, 2006; Marsland and McLachlan, 2007; Younes, 2007; Younes et al., 2008, 2009</xref>) or in various textbooks (<xref rid="bb0160 bb0090 bb0085" ref-type="bibr">Younes, 2010; Holm et al., 2009; Grenander and Miller, 2007</xref>). This section will simply outline how a deformation and its inverse may be computed from an initial velocity field, by Euler integration.</p>
        <p>Geodesic shooting requires the initial momentum (<bold>u</bold><sub>0</sub>), which is derived from the initial velocity by applying <bold>L</bold><sup>†</sup><bold>L</bold>.<disp-formula id="fo0040"><label>(8)</label><alternatives><textual-form specific-use="jats-markup"><bold>u</bold><sub>0</sub> = <bold>L</bold><sup>†</sup><bold>L</bold><bold>v</bold><sub>0</sub></textual-form><mml:math id="M12" altimg="si12.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="bold">u</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="bold">L</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mi mathvariant="bold">L</mml:mi><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>The inverse (backward) deformations are initialised to the identity and, if required, their Jacobian tensor fields are set to an identity matrix at each point. Here, the <bold>D</bold> operator is used to denote computing the Jacobian tensor at each point in the image. In this case, the Jacobian tensors from an identity transform are all identity matrices.<disp-formula id="fo0045"><label>(9)</label><mml:math id="M13" altimg="si13.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi>ϑ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mtext>Id</mml:mtext><mml:mtext>,</mml:mtext><mml:mspace width="0.5em"/><mml:msubsup><mml:mi mathvariant="bold">J</mml:mi><mml:mn>0</mml:mn><mml:mi>ϑ</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mi mathvariant="bold">D</mml:mi><mml:msub><mml:mi>ϑ</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></disp-formula></p>
        <p>If required, the forward deformation is also initialised to an identity transform, and possibly also its Jacobian tensor field.<disp-formula id="fo0050"><label>(10)</label><mml:math id="M14" altimg="si14.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi>φ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mtext>Id</mml:mtext><mml:mtext>,</mml:mtext><mml:mspace width="0.5em"/><mml:msubsup><mml:mi mathvariant="bold">J</mml:mi><mml:mn>0</mml:mn><mml:mi>φ</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mi mathvariant="bold">D</mml:mi><mml:msub><mml:mi>φ</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></disp-formula></p>
        <p>Then the following (Eqs. <xref rid="fo0055 fo0060 fo0065 fo0070 fo0075 fo0080" ref-type="disp-formula">(11) to (16)</xref>) are executed for each of <italic>N</italic> time steps. For the <italic>n</italic>th time step, the backward deformation is incremented by composing it with a small-deformation.<disp-formula id="fo0055"><label>(11)</label><mml:math id="M15" altimg="si15.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi>ϑ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>ϑ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub><mml:mo>∘</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mi mathvariant="bold">v</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
        <p>This procedure requires the Jacobians of this deformation. These may be constructed from the sequential composition of the Jacobians of the small-deformations, but may also be derived by computing the gradients of <italic>ϑ</italic><sub><italic>t</italic><sub><italic>n</italic> − 1</sub></sub>. The procedure involves matrix multiplications with the 3 × 3 Jacobian tensors at each point.<disp-formula id="fo0060"><label>(12)</label><mml:math id="M16" altimg="si16.gif" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="bold">J</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>ϑ</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mfenced open="(" close=")"><mml:mrow><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>ϑ</mml:mi></mml:msubsup><mml:mo>∘</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>T</mml:mi></mml:msup><mml:mfenced open="(" close=")"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">D</mml:mi></mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
        <p>A forward deformation and its Jacobian tensor field may be required, but it is not strictly necessary for the integration.<disp-formula id="fo0065"><label>(13)</label><mml:math id="M17" altimg="si17.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi>φ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></disp-formula><disp-formula id="fo0070"><label>(14)</label><mml:math id="M18" altimg="si18.gif" overflow="scroll"><mml:mrow><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>φ</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">D</mml:mi></mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>φ</mml:mi></mml:msubsup></mml:mrow></mml:math></disp-formula></p>
        <p>The velocity field is updated, by first generating a view of the momentum, which accounts for the current deformation.<disp-formula id="fo0075"><label>(15)</label><mml:math id="M19" altimg="si19.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mstyle><mml:mi mathvariant="bold">u</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>ϑ</mml:mi></mml:msubsup><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>ϑ</mml:mi></mml:msubsup></mml:mfenced></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mstyle><mml:mi mathvariant="bold">u</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub><mml:mo>∘</mml:mo><mml:msub><mml:mi>ϑ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
        <p>Velocity is then obtained from the momentum by applying the <bold>K</bold> operator. Fourier transform methods may be used to effect this convolution, but other approaches, such as the multi-grid methods used in the current paper, are also possible.<disp-formula id="fo0080"><label>(16)</label><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub><italic>t</italic><sub><italic>n</italic></sub></sub> = <bold>K</bold><bold>u</bold><sub><italic>t</italic><sub><italic>n</italic></sub></sub></textual-form><mml:math id="M20" altimg="si21.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:mstyle><mml:mi mathvariant="bold">K</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">u</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></disp-formula></p>
        <sec id="s0020">
          <title>An alternative integration scheme</title>
          <p>The registration algorithms described in this paper use an alternative integration scheme, which is now presented. Rather than transforming the initial momentum using <italic>ϑ</italic><sub><italic>t</italic></sub> with a pullback scheme, it uses <italic>φ</italic><sub><italic>t</italic></sub> with a push-forward. It is therefore more suited to the direct computation of <italic>φ</italic><sub>1</sub> from <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub>0</sub></textual-form><mml:math id="M21" altimg="si22.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>.</p>
          <p>The procedure begins by computing the initial momentum from its velocity (Eq. <xref rid="fo0040" ref-type="disp-formula">(8)</xref>), and setting the forward deformation and its Jacobian tensor field to identity transforms (Eq. <xref rid="fo0050" ref-type="disp-formula">(10)</xref>). Then the following (Eqs. <xref rid="fo0085 fo0090 fo0095 fo0100" ref-type="disp-formula">(17) to (20)</xref>) are computed for each of the <italic>N</italic> time steps.</p>
          <p>Update the forward deformation using Eq. <xref rid="fo0065" ref-type="disp-formula">(13)</xref>.<disp-formula id="fo0085"><label>(17)</label><mml:math id="M22" altimg="si23.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi>φ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Id</mml:mtext><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:math></disp-formula></p>
          <p>In this integration strategy, the inverses of the Jacobian matrices at each point will be used. If relatively few time steps are used, the possibility of small-deformations containing Jacobians with zero or negative determinants becomes more likely. To increase stability, the computation of the Jacobian tensor field is therefore modified slightly, replacing the small-deformation approximation of the Jacobians by the matrix exponentials (eg, see <xref rid="bb0130" ref-type="bibr">Moler and Van Loan (2003)</xref>) of the gradients at each point of the velocity field. The use of matrix exponentials is to ensure that the Jacobians are invertable (by preventing their determinants from approaching zero), even though the small-deformation itself may not have positive Jacobian determinants.<disp-formula id="fo0090"><label>(18)</label><mml:math id="M23" altimg="si24.gif" overflow="scroll"><mml:mrow><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>φ</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mtext>Exp</mml:mtext><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mstyle><mml:mi mathvariant="bold">D</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:msub></mml:mrow></mml:mfenced></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>φ</mml:mi></mml:msubsup></mml:mrow></mml:math></disp-formula></p>
          <p>Obtaining the new view of the momentum involves a push-forward scheme. This will be denoted by <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>φ</italic><sup>⁎</sup><bold>u</bold></textual-form><mml:math id="M24" altimg="si25.gif" overflow="scroll"><mml:mrow><mml:msup><mml:mi>φ</mml:mi><mml:mo>⁎</mml:mo></mml:msup><mml:mstyle><mml:mi mathvariant="bold">u</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula>, and involves adding each of the voxels in <bold>u</bold> into the appropriate positions of the warped version. The end result is similar to <inline-formula><alternatives><textual-form specific-use="jats-markup">|<bold>J</bold><sup><italic>φ</italic><sup> − 1</sup></sup>|(<bold>u</bold> ∘ <italic>φ</italic><sup> − 1</sup>)</textual-form><mml:math id="M25" altimg="si27.gif" overflow="scroll"><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msup><mml:mi>φ</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">u</mml:mi></mml:mstyle><mml:mo>∘</mml:mo><mml:msup><mml:mi>φ</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:math></alternatives></inline-formula>, but contains some aliasing effects.<disp-formula id="fo0095"><label>(19)</label><mml:math id="M26" altimg="si28.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mstyle><mml:mi mathvariant="bold">u</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>φ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>⁎</mml:mo></mml:msubsup><mml:mfenced open="(" close=")"><mml:mrow><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>φ</mml:mi></mml:msubsup></mml:mfenced></mml:mstyle><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mfenced></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mstyle><mml:mi mathvariant="bold">u</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
          <p>The final procedure within each time step is to update the velocity (Eq. <xref rid="fo0080" ref-type="disp-formula">(16)</xref>).<disp-formula id="fo0100"><label>(20)</label><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub><italic>t</italic><sub><italic>n</italic></sub></sub> = <bold>K</bold><bold>u</bold><sub><italic>t</italic><sub><italic>n</italic></sub></sub></textual-form><mml:math id="M27" altimg="si29.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:mstyle><mml:mi mathvariant="bold">K</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">u</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub></mml:mrow></mml:math></alternatives></disp-formula></p>
        </sec>
      </sec>
      <sec id="s0025">
        <title>Optimisation</title>
        <p>In this work, registration is viewed as an optimisation procedure, where the objective is to estimate the initial velocity field, parameterising the diffeomorphism that best aligns the images. An optimisation scheme based on using approximations to both first and second derivatives is presented. It will be described for a matching term based on the sum of squares difference, but other objective functions may also be used.</p>
        <p>Conservation of “kinetic energy” allows the registration objective function to be formulated as:<disp-formula id="fo0105"><label>(21)</label><mml:math id="M28" altimg="si30.gif" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:maligngroup/><mml:mi mathvariant="script">E</mml:mi><mml:mo>=</mml:mo><mml:malignmark/><mml:msub><mml:mi mathvariant="script">E</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi mathvariant="script">E</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:maligngroup/><mml:mo>=</mml:mo><mml:malignmark/><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mstyle><mml:msub><mml:mo>∫</mml:mo><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>∈</mml:mo><mml:mi>Ω</mml:mi></mml:mrow></mml:msub></mml:mstyle><mml:mspace width="0.12em"/><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msubsup><mml:mi>φ</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn></mml:msup><mml:mi>d</mml:mi><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
        <p>This objective function can be re-written as the difference between the template and warped image, by including a change of variables to account for expansion and contraction.<disp-formula id="fo0110"><label>(22)</label><mml:math id="M29" altimg="si31.gif" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo>=</mml:mo><mml:malignmark/><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mstyle><mml:msub><mml:mo>∫</mml:mo><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>∈</mml:mo><mml:mi>Ω</mml:mi></mml:mrow></mml:msub></mml:mstyle><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:mn>1</mml:mn><mml:mi>φ</mml:mi></mml:msubsup><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn></mml:msup><mml:mi>d</mml:mi><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle></mml:mrow></mml:math></disp-formula></p>
        <p>For each iteration of LDDMM, all the relevant deformations (<italic>ϑ</italic><sub><italic>t</italic><sub><italic>n</italic></sub></sub> and <italic>φ</italic><sub>1</sub>) are computed from the current estimates of the velocity fields (<inline-formula><mml:math id="M30" altimg="si32.gif" overflow="scroll"><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi mathvariant="italic">iter</mml:mi></mml:msubsup></mml:math></inline-formula>), and then the velocity fields are updated by a descent step (scaled by <italic>ε</italic>) along the, so called, Hilbert gradient. Briefly, the Hilbert gradient may be considered as the derivatives of the objective function with respect to variations in the velocity, if this velocity were parameterised by a linear combination of Green's functions similar to those shown in <xref rid="f0005" ref-type="fig">Fig. 1</xref>. Without including the <bold>K</bold> operator in the update equations (to give the Hilbert gradient), the gradient descent would be much less stable. In the following update equation, the multiplications by <inline-formula><mml:math id="M31" altimg="si34.gif" overflow="scroll"><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>ϑ</mml:mi></mml:msubsup></mml:mfenced></mml:mstyle><mml:mi>T</mml:mi></mml:msup></mml:math></inline-formula> account for the changes to the template gradients as it is warped over time (see later). Similarly, Jacobian determinants are included because of the change of variables needed to account for expansion or contraction of the individual image. The following gradient descent step is simply a re-expression of Eqs. (10) and (12) of <xref rid="bb0050" ref-type="bibr">Beg et al. (2005)</xref>.<disp-formula id="fo0115"><label>(23)</label><mml:math id="M32" altimg="si35.gif" overflow="scroll"><mml:mrow><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mrow><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi mathvariant="italic">iter</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle><mml:mi mathvariant="bold">K</mml:mi></mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:mo>†</mml:mo></mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi mathvariant="italic">iter</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>ϑ</mml:mi></mml:msubsup><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>ϑ</mml:mi></mml:msubsup><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mfenced open="(" close=")"><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:mn>1</mml:mn><mml:mi mathvariant="italic">φ</mml:mi></mml:msubsup><mml:mo stretchy="true">|</mml:mo></mml:mrow><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mfrac><mml:mo stretchy="true">(</mml:mo><mml:mi>f</mml:mi><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">)</mml:mo><mml:mo>∇</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:msub><mml:mi>ϑ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
        <p>This procedure, which involves alternating between updating all the deformations, and updating all the velocities, is repeated until convergence or until some limit on the number of iterations is reached.</p>
        <p>Differentiating <italic>φ</italic><sub>1</sub> with respect to variations in <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub>0</sub></textual-form><mml:math id="M33" altimg="si36.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula> is not straightforward, when it is computed via GS. This leads to difficulties in computing the exact derivatives needed for Gauss–Newton optimisation. Therefore, an alternative strategy is adopted. First of all though, the principles of how the initial velocity could be optimised using gradient descent will be illustrated. Simplifying Eq. <xref rid="fo0115" ref-type="disp-formula">(23)</xref> for the special case of the initial velocity gives the following gradient descent step.<disp-formula id="fo0120"><label>(24)</label><mml:math id="M34" altimg="si37.gif" overflow="scroll"><mml:mrow><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn><mml:mrow><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn><mml:mi mathvariant="italic">iter</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle><mml:mi mathvariant="bold">K</mml:mi></mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:mo>†</mml:mo></mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn><mml:mi mathvariant="italic">iter</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:mn>1</mml:mn><mml:mi>φ</mml:mi></mml:msubsup><mml:mo stretchy="true">|</mml:mo></mml:mrow><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mfrac><mml:mo stretchy="true">(</mml:mo><mml:mi>f</mml:mi><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">)</mml:mo><mml:mo>∇</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
        <p>In essence, the LDDMM algorithm (<xref rid="bb0050" ref-type="bibr">Beg et al., 2005</xref>) updates <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub>0</sub></textual-form><mml:math id="M35" altimg="si38.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula> using Eq. <xref rid="fo0120" ref-type="disp-formula">(24)</xref>, and would normally proceed to update the remaining velocity fields using Eq. <xref rid="fo0115" ref-type="disp-formula">(23)</xref>. However, rather than updating the remaining fields by gradient descent, they could instead be updated by shooting from <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub>0</sub></textual-form><mml:math id="M36" altimg="si39.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>. This is a similar procedure to that employed in <xref rid="bb0070 bb0115" ref-type="bibr">Cotter and Holm (2006) and Marsland and McLachlan (2007)</xref>. Providing the gradient descent step on the initial velocity brings it closer to its optimal solution, the updates of the remaining velocity fields should also be brought closer to their optima.</p>
        <p>The Gauss–Newton approach is now described, which uses both first and second derivatives. To make the problem tractable, at each iteration the update can be conceptualised as estimating a small displacement field (<bold>s</bold>) that would improve the objective function. The estimated displacement is treated as an increment to the initial velocity, which is then used to update the deformation via geodesic shooting. Deriving the first and second derivatives necessary for each iteration of this approach involves differentiating the following (around <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>s</bold> = 0</textual-form><mml:math id="M37" altimg="si41.gif" overflow="scroll"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">s</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>), with respect to variations in <bold>s</bold> (while holding <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub>0</sub></textual-form><mml:math id="M38" altimg="si43.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>φ</italic><sub>1</sub></textual-form><mml:math id="M39" altimg="si44.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi>φ</mml:mi></mml:mstyle><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> fixed):<disp-formula id="fo0125"><label>(25)</label><mml:math id="M40" altimg="si45.gif" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mstyle><mml:mi mathvariant="bold">s</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true">|</mml:mo></mml:mrow></mml:mstyle><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">s</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mstyle><mml:msub><mml:mo>∫</mml:mo><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>∈</mml:mo><mml:mi>Ω</mml:mi></mml:mrow></mml:msub></mml:mstyle><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:mn>1</mml:mn><mml:mi>φ</mml:mi></mml:msubsup><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>−</mml:mo><mml:mstyle><mml:mi mathvariant="bold">s</mml:mi></mml:mstyle><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn></mml:msup><mml:mi>d</mml:mi><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">|</mml:mo></mml:mrow></mml:mstyle><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">s</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p>
        <p>Because it is often easier to discretise the problem prior to optimising, the descriptions in the remainder of this section will use a discrete formulation. The initial velocities are now represented as a linear combination of trilinear interpolation basis functions. The value of each point (<bold>x</bold>) in the continuous vector field (<inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub>0</sub>(<bold>x</bold>)</textual-form><mml:math id="M41" altimg="si47.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>) is encoded by <inline-formula><mml:math id="M42" altimg="si48.gif" overflow="scroll"><mml:mrow><mml:mstyle><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>I</mml:mi></mml:msubsup></mml:mstyle><mml:mspace width="0.12em"/><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mstyle><mml:mi mathvariant="bold">b</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>b</bold><sub><italic>i</italic></sub>(<bold>x</bold>)</textual-form><mml:math id="M43" altimg="si49.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mstyle><mml:mi mathvariant="bold">b</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is the <italic>i</italic>th basis function. Similarly, <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>s</bold>(<bold>x</bold>)</textual-form><mml:math id="M44" altimg="si50.gif" overflow="scroll"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">s</mml:mi></mml:mstyle><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> in Eq. <xref rid="fo0125" ref-type="disp-formula">(25)</xref> is parameterised the same way. The registration involves estimating the vector of <italic>I</italic> coefficients <bold>w</bold>. Within the discrete setting, <inline-formula><alternatives><textual-form specific-use="jats-markup">½||<bold>L</bold><bold>v</bold><sub>0</sub>||<sup>2</sup></textual-form><mml:math id="M45" altimg="si52.gif" overflow="scroll"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> may be computed by <inline-formula><alternatives><textual-form specific-use="jats-markup">½<bold>w</bold><sup><italic>T</italic></sup><bold>A</bold><bold>w</bold></textual-form><mml:math id="M46" altimg="si53.gif" overflow="scroll"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula>, where <bold>A</bold> is a very large sparse matrix encoding the operator <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>L</bold><sup>†</sup><bold>L</bold></textual-form><mml:math id="M47" altimg="si55.gif" overflow="scroll"><mml:mrow><mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:mo>†</mml:mo></mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula>. See, for example, <xref rid="bb0125" ref-type="bibr">Modersitzki (2009)</xref> for further details about how such operators may be formulated as matrices. Within this discrete setting, the gradient descent update in Eq. <xref rid="fo0120" ref-type="disp-formula">(24)</xref> may be expressed as:<disp-formula id="fo0130"><label>(26)</label><alternatives><textual-form specific-use="jats-markup"><bold>w</bold><sup><italic>i</italic><italic>t</italic><italic>e</italic><italic>r</italic> + 1</sup> = <bold>w</bold><sup><italic>iter</italic></sup> − <italic>ε</italic><bold>A</bold><sup> − 1</sup>(<bold>A</bold><bold>w</bold><sup><italic>iter</italic></sup> + <bold>g</bold><sup><italic>iter</italic></sup>)</textual-form><mml:math id="M48" altimg="si56.gif" overflow="scroll"><mml:mrow><mml:msup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi mathvariant="italic">iter</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:msup><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi></mml:mstyle><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mfenced open="(" close=")"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi></mml:mstyle><mml:msup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi mathvariant="italic">iter</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mstyle><mml:mi mathvariant="bold">g</mml:mi></mml:mstyle><mml:mi mathvariant="italic">iter</mml:mi></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>For the 3D case, the vector of first derivatives may be written in terms of its three components as:<disp-formula id="fo0135"><label>(27)</label><mml:math id="M49" altimg="si57.gif" overflow="scroll"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">g</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"><mml:mtable columnalign="center"><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">g</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">g</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">g</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
        <p>The velocity is parameterised using trilinear interpolation basis functions, so using ∇ <sub><italic>l</italic></sub> to indicate the gradient along the <italic>l</italic>th dimension, the components of the derivatives are computed by:<disp-formula id="fo0140"><label>(28)</label><mml:math id="M50" altimg="si58.gif" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:msub><mml:mi mathvariant="script">E</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mfrac><mml:mfenced open="|" close="|"><mml:mrow><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:mn>1</mml:mn><mml:mi>φ</mml:mi></mml:msubsup><mml:mfenced open="(" close=")"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub></mml:mfenced></mml:mrow></mml:mfenced><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>f</mml:mi><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mfenced open="(" close=")"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub></mml:mfenced><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mfenced open="(" close=")"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mfenced open="(" close=")"><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mo>∇</mml:mo><mml:mi>l</mml:mi></mml:msub><mml:mi>μ</mml:mi></mml:mrow></mml:mfenced><mml:mo>∘</mml:mo><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p>
        <p>Convergence of gradient descent algorithms is often much slower than that of algorithms that also use second derivatives. By including an approximation of the Hessian of <inline-formula><alternatives><textual-form specific-use="jats-markup">ℰ<sub>2</sub></textual-form><mml:math id="M51" altimg="si59.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="script">E</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> within the optimisation, it is possible to make the update steps more effective. Including the Hessian (<bold>H</bold>) to obtain a Gauss-Newton optimisation involves a slight change to Eq. <xref rid="fo0130" ref-type="disp-formula">(26)</xref>.<disp-formula id="fo0145"><label>(29)</label><alternatives><textual-form specific-use="jats-markup"><bold>w</bold><sup><italic>i</italic><italic>t</italic><italic>e</italic><italic>r</italic> + 1</sup> = <bold>w</bold><sup><italic>iter</italic></sup> − <italic>γ</italic>(<bold>A</bold> + <bold>H</bold><sup><italic>iter</italic></sup>)<sup> − 1</sup>(<bold>A</bold><bold>w</bold><sup><italic>iter</italic></sup> + <bold>g</bold><sup><italic>iter</italic></sup>)</textual-form><mml:math id="M52" altimg="si61.gif" overflow="scroll"><mml:mrow><mml:msup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi mathvariant="italic">iter</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mi>γ</mml:mi><mml:msup><mml:mfenced open="(" close=")"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi></mml:mstyle><mml:mo>+</mml:mo><mml:msup><mml:mstyle><mml:mi mathvariant="bold">H</mml:mi></mml:mstyle><mml:mi mathvariant="italic">iter</mml:mi></mml:msup></mml:mrow></mml:mfenced><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mfenced open="(" close=")"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi></mml:mstyle><mml:msup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi mathvariant="italic">iter</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mstyle><mml:mi mathvariant="bold">g</mml:mi></mml:mstyle><mml:mi mathvariant="italic">iter</mml:mi></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>The foregoing equation is a slightly modified version of the pure Gauss–Newton update formula, as it includes a scaling parameter (<italic>γ</italic>), which may be used to prevent updates from overshooting. For a pure Gauss–Newton approach, <italic>γ</italic> would be set to 1, but there may be situations where its value should be decreased. For example, after an iteration in which the objective function gets worse, it can be a good idea to halve the value of <italic>γ</italic>. This situation can occur with the diffeomorphic registration procedure, but it also happens when optimising small-deformation registration models.</p>
        <p>Instead of the true Hessian (of Eq. <xref rid="fo0125" ref-type="disp-formula">(25)</xref>), a positive semi-definite approximation is used, that ignores derivatives of the template that are higher than first order (see eg <xref rid="bb0125" ref-type="bibr">Modersitzki (2009)</xref>). Just as the first derivatives (<bold>g</bold>) may be computed by differentiating Eq. <xref rid="fo0125" ref-type="disp-formula">(25)</xref> around <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>s</bold> = 0</textual-form><mml:math id="M53" altimg="si63.gif" overflow="scroll"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">s</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>, so the Hessian (<bold>H</bold>) may be computed in a similar way. Again, because the velocity field is modelled using trilinear interpolation, these second derivatives of <inline-formula><alternatives><textual-form specific-use="jats-markup">ℰ<sub>2</sub></textual-form><mml:math id="M54" altimg="si65.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="script">E</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> (based on Eq. <xref rid="fo0125" ref-type="disp-formula">(25)</xref>) have the following form:<disp-formula id="fo0150"><label>(30)</label><mml:math id="M55" altimg="si66.gif" overflow="scroll"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">H</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"><mml:mtable columnalign="center"><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:mrow><mml:mtext>diag</mml:mtext><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">h</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mtd><mml:mtd columnalign="center"><mml:mrow><mml:mtext>diag</mml:mtext><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">h</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>12</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mtd><mml:mtd columnalign="center"><mml:mrow><mml:mtext>diag</mml:mtext><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">h</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>13</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:mrow><mml:mtext>diag</mml:mtext><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">h</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>12</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mtd><mml:mtd columnalign="center"><mml:mrow><mml:mtext>diag</mml:mtext><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">h</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>22</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mtd><mml:mtd columnalign="center"><mml:mrow><mml:mtext>diag</mml:mtext><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">h</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>23</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:mrow><mml:mtext>diag</mml:mtext><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">h</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>13</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mtd><mml:mtd columnalign="center"><mml:mrow><mml:mtext>diag</mml:mtext><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">h</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>23</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mtd><mml:mtd columnalign="center"><mml:mrow><mml:mtext>diag</mml:mtext><mml:mfenced open="(" close=")"><mml:msup><mml:mstyle><mml:mi mathvariant="bold">h</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>33</mml:mn><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:mrow></mml:math></disp-formula>where:<disp-formula id="fo0155"><label>(31)</label><mml:math id="M56" altimg="si67.gif" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mi>l</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:mn>1</mml:mn><mml:mi>φ</mml:mi></mml:msubsup><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mo>∇</mml:mo><mml:mi>l</mml:mi></mml:msub><mml:mi>μ</mml:mi><mml:mo stretchy="true">)</mml:mo><mml:mo>∘</mml:mo><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mo>∇</mml:mo><mml:mi>m</mml:mi></mml:msub><mml:mi>μ</mml:mi><mml:mo stretchy="true">)</mml:mo><mml:mo>∘</mml:mo><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>The overall algorithm is summarised as follows.<list list-type="simple"><list-item><label>•</label><p>Set the initial velocity <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub>0</sub></textual-form><mml:math id="M57" altimg="si68.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula> (parameterised by <bold>w</bold>) to zero, and <italic>γ</italic> to 1.</p></list-item><list-item><label>•</label><p>Repeat the following until convergence or for a fixed number of iterations<list list-type="simple"><list-item><label>-</label><p>Shoot from the initial velocity <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub>0</sub></textual-form><mml:math id="M58" altimg="si70.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula> to obtain <italic>φ</italic><sub>1</sub>.</p></list-item><list-item><label>-</label><p>Compute the objective function, and approximate gradient and Hessian (ℰ, <bold>g</bold> and <bold>H</bold>), using the current <italic>φ</italic><sub>1</sub>. These are in Eqs. <xref rid="fo0110 fo0135 fo0150" ref-type="disp-formula">(22), (27) and (30)</xref>.</p></list-item><list-item><label>-</label><p>If ℰ is worse than that from the previous iteration, decrease <italic>γ</italic>.</p></list-item><list-item><label>-</label><p>The coefficients, which parameterise <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>v</bold><sub>0</sub></textual-form><mml:math id="M59" altimg="si75.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>, are updated using Eq. <xref rid="fo0145" ref-type="disp-formula">(29)</xref>.</p></list-item></list></p></list-item></list></p>
        <p>The Gauss–Newton updates involve very large sparse matrices. Various numerical optimisation techniques may be used for computing <inline-formula><alternatives><textual-form specific-use="jats-markup">[<bold>H</bold> + <bold>A</bold>]<sup> − 1</sup>[<bold>g</bold> + <bold>A</bold><bold>w</bold>]</textual-form><mml:math id="M60" altimg="si76.gif" overflow="scroll"><mml:mrow><mml:msup><mml:mstyle><mml:mfenced open="[" close="]"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">H</mml:mi></mml:mstyle><mml:mo>+</mml:mo><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi></mml:mstyle></mml:mrow></mml:mfenced></mml:mstyle><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mfenced open="[" close="]"><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">g</mml:mi></mml:mstyle><mml:mo>+</mml:mo><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle></mml:mrow></mml:mfenced></mml:mrow></mml:math></alternatives></inline-formula>, many of which are outlined by <xref rid="bb0125" ref-type="bibr">Modersitzki (2009)</xref>. A multi-grid approach was used for the work described in this paper, which was the same implementation as used in <xref rid="bb0025" ref-type="bibr">Ashburner (2007)</xref>.</p>
      </sec>
    </sec>
    <sec id="s0030">
      <title>Results and discussion</title>
      <p>This paper is concerned with increasing the efficiency of LDDMM, and focuses on one aspect of image registration. The aim here is simply to demonstrate some of the desirable properties of the algorithm, and to assess the accuracy of the resulting image alignment. A two-dimensional toy example is provided next, which illustrates some of the properties of the resulting deformations. This is followed by an evaluation of the label propagation accuracy obtained when the algorithm is applied to real three-dimensional brain images. Then there is an illustration of the rate of convergence with real three-dimensional data, which is followed by the final section demonstrating some of the invariance properties of the GS formulation.</p>
      <sec id="s0035">
        <title>Two-dimensional example</title>
        <p>Two simulated two-dimensional images (128 × 128 pixels) were registered together to illustrate the underlying principles. An image containing two concentric circles was used as the template (<italic>μ</italic>), and the target (<italic>f</italic>) was an image of a more complex shape (shown in <xref rid="f0010" ref-type="fig">Fig. 2</xref>). The objective function was the sum of squares difference between the target and warped template images, and the operator (<inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>L</bold><sup>†</sup><bold>L</bold></textual-form><mml:math id="M61" altimg="si77.gif" overflow="scroll"><mml:mrow><mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:mo>†</mml:mo></mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula>) encoded linear elasticity (as used by <xref rid="bb0065" ref-type="bibr">Christensen et al. (1996)</xref>). The boundary conditions were circulant, and the Euler integration used 20 time steps. To illustrate the effectiveness of the Gauss–Newton approach, <xref rid="f0015" ref-type="fig">Fig. 3</xref> shows a plot of the objective function with each iteration. For this example, a reasonably accurate solution is achieved within about 20 to 30 iterations.</p>
        <p><xref rid="f0020" ref-type="fig">Fig. 4</xref> illustrates the evolution equations that construct diffeomorphic deformations from an initial velocity or momentum field. The first column shows the template as it is deformed over time (<italic>μ</italic> ∘ <italic>ϑ</italic><sub><italic>t</italic><sub><italic>n</italic></sub></sub>), and its horizontal and vertical spatial gradients (∇ (<italic>μ</italic> ∘ <italic>ϑ</italic><sub><italic>t</italic><sub><italic>n</italic></sub></sub>), which may also be computed by <inline-formula><mml:math id="M62" altimg="si78.gif" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>ϑ</mml:mi></mml:msubsup><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="true">(</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mo>∇</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">)</mml:mo><mml:mo>∘</mml:mo><mml:msub><mml:mi>ϑ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></inline-formula>). This is followed by a column of residual images, constructed from <inline-formula><mml:math id="M63" altimg="si79.gif" overflow="scroll"><mml:mrow><mml:mstyle><mml:mfrac><mml:mn>1</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mfrac></mml:mstyle><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>ϑ</mml:mi></mml:msubsup><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:mn>1</mml:mn><mml:mi>φ</mml:mi></mml:msubsup><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>−</mml:mo><mml:mi>f</mml:mi><mml:mo>∘</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mo>∘</mml:mo><mml:msub><mml:mi>ϑ</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></inline-formula>. Next is the momentum at different time points, which may be constructed by multiplying the warped residuals by the gradients of the warped template. Obtaining the velocity fields (<bold>v</bold>) from the momentum is by applying <bold>K</bold> (Eqs. <xref rid="fo0080 fo0100" ref-type="disp-formula">(16) or (20)</xref>), which is essentially a convolution with the function shown in <xref rid="f0005" ref-type="fig">Fig. 1</xref>. These time varying velocity fields are shown in the next column. Updates to the backward and forward deformations may then be made by composing with small-deformations constructed using this velocity field (Eqs. <xref rid="fo0055 fo0060 fo0065 fo0070" ref-type="disp-formula">(11) to (14)</xref>). These deformations, along with their Jacobian determinants are shown in the final four columns.</p>
        <sec id="s0040">
          <title>Comparison with some other parameterisations</title>
          <p>The same 2D examples were also registered using some other approaches, with the aim of illustrating some of the limitations that are overcome using the diffeomorphic formulation. The first of these involved parameterising with a one-parameter subgroup, which allows diffeomorphic mappings to be constructed via a scaling and squaring procedure (<xref rid="bb0015 bb0025 bb0020" ref-type="bibr">Arsigny et al., 2006; Ashburner, 2007; Arsigny et al., 2009</xref>). It was intended to serve as a fast approximation to the full diffeomorphic framework described in this work. An inverse consistent formulation was used, which involved minimising the following<disp-formula id="fo0160"><label>(32)</label><alternatives><textual-form specific-use="jats-markup">ℰ<sub><italic>ops</italic></sub> = ½||<bold>L</bold><bold>v</bold>||<sup>2</sup> + ¼∫<sub><bold>x</bold> ∈ <italic>Ω</italic></sub> (<italic>f</italic>(<bold>x</bold>) − <italic>μ</italic>(<italic>χ</italic><sup> − 1</sup>(<bold>x</bold>)))<sup>2</sup><italic>d</italic><bold>x</bold> + ¼∫<sub><bold>x</bold> ∈ <italic>Ω</italic></sub> (<italic>μ</italic>(<bold>x</bold>) − <italic>f</italic>(<italic>χ</italic>(<bold>x</bold>)))<sup>2</sup><italic>d</italic><bold>x</bold></textual-form><mml:math id="M64" altimg="si82.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="script">E</mml:mi><mml:mi mathvariant="italic">ops</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>4</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mstyle><mml:msub><mml:mo>∫</mml:mo><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>∈</mml:mo><mml:mi>Ω</mml:mi></mml:mrow></mml:msub></mml:mstyle><mml:mspace width="0.12em"/><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msup><mml:mi>χ</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn></mml:msup><mml:mi>d</mml:mi><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>4</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mstyle><mml:msub><mml:mo>∫</mml:mo><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>∈</mml:mo><mml:mi>Ω</mml:mi></mml:mrow></mml:msub></mml:mstyle><mml:mspace width="0.12em"/><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>μ</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo>−</mml:mo><mml:mi>f</mml:mi><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>χ</mml:mi><mml:mfenced open="(" close=")"><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn></mml:msup><mml:mi>d</mml:mi><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></disp-formula>where <bold>χ</bold> is computed by integrating χ̇ = <bold>v(χ)</bold> over unit time, after initially setting <bold>χ</bold> to an identity transform. The inverse (<italic>χ</italic><sup>− 1</sup>) may be computed by simply reversing the sign of <bold>v</bold>. Eight squaring steps were used, which corresponds to an Euler integration with 256 time steps. The same linear elasticity metric was used as a regulariser and also the same value of <italic>σ</italic><sup>2</sup>. The results of this registration are presented in the left-hand panel of <xref rid="f0025" ref-type="fig">Fig. 5</xref>, and show that the log-Euclidean approximation achieves a reasonably good overlap between the two images. The log-Euclidean approximation is unable to encode all possible diffeomorphic mappings (see page 456 of <xref rid="bb0110" ref-type="bibr">Kriegl and Michor (1997)</xref>), so the model had to introduce additional distortions to achieve this overlap. This is particularly visible in the Jacobians when they are compared to those in <xref rid="f0010" ref-type="fig">Fig. 2</xref>. It is readily apparent that the log-Euclidean approach does not localise volumetric differences as accurately as the shooting approach. This is likely to make the GS approach more suited to morphometric applications.</p>
          <p>Two small-deformation models were also included (both using the same regularisation), the first of which involved warping the template to match the individual. The displacement field (<bold>v</bold>) was found that minimises<disp-formula id="fo0165"><label>(33)</label><alternatives><textual-form specific-use="jats-markup">ℰ<sub><italic>s</italic><italic>d</italic>1</sub> = ½||<bold>L</bold><bold>v</bold>||<sup>2</sup> + ½∫<sub><bold>x</bold> ∈ <italic>Ω</italic></sub> (<italic>f</italic>(<bold>x</bold>) − <italic>μ</italic>(<bold>x</bold> − <bold>v</bold>(<bold>x</bold>)))<sup>2</sup><italic>d</italic><bold>x</bold></textual-form><mml:math id="M65" altimg="si86.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="script">E</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mstyle><mml:msub><mml:mo>∫</mml:mo><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>∈</mml:mo><mml:mi>Ω</mml:mi></mml:mrow></mml:msub></mml:mstyle><mml:mspace width="0.12em"/><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>−</mml:mo><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn></mml:msup><mml:mi>d</mml:mi><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></disp-formula></p>
          <p>Registration results from this model are presented in the centre panel of <xref rid="f0025" ref-type="fig">Fig. 5</xref> and show that this model was unable to achieve a good overlap between the images. When compared with the results in <xref rid="f0010" ref-type="fig">Fig. 2</xref>, it should be readily apparent that the inverse of a deformation cannot be achieved by negating a displacement field. This illustrates the fact that combined deformations cannot be computed accurately by simply adding or subtracting displacement fields, and therefore that the study of shapes cannot be optimally achieved using simple linear models. Another issue is that the resulting Jacobian determinants were not all positive, indicating that the one-to-one mapping has broken down and the deformations are not invertable. Negative Jacobian determinants also pose a problem for morphometric applications that involve working with logarithms of Jacobians. Also of note is the fact that the Jacobian determinants are not in alignment with the template image, which is another reason why this approach may be unsuited to morphometric applications.</p>
          <p>The second small-deformation model involved warping the individual to the template, by minimising the following.<disp-formula id="fo0170"><label>(34)</label><alternatives><textual-form specific-use="jats-markup">ℰ<sub><italic>s</italic><italic>d</italic>2</sub> = ½||<bold>L</bold><bold>v</bold>||<sup>2</sup> + ½∫<sub><bold>x</bold> ∈ <italic>Ω</italic></sub> (<italic>f</italic>(<bold>x</bold> + <bold>v</bold>(<bold>x</bold>)) − <italic>μ</italic>(<bold>x</bold>))<sup>2</sup><italic>d</italic><bold>x</bold></textual-form><mml:math id="M66" altimg="si87.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="script">E</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mstyle><mml:msub><mml:mo>∫</mml:mo><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>∈</mml:mo><mml:mi>Ω</mml:mi></mml:mrow></mml:msub></mml:mstyle><mml:mspace width="0.12em"/><mml:msup><mml:mstyle><mml:mfenced open="(" close=")"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>+</mml:mo><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn></mml:msup><mml:mi>d</mml:mi><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></disp-formula></p>
          <p>This formulation of a small-deformation model is less correct from a generative modelling perspective, as it does not allow an image to be treated as a sample from the probability density encoded by the model. However, it is an approach that is commonly used for spatially normalising multiple images to the same template. The results of this model are illustrated in the right-hand panel of <xref rid="f0025" ref-type="fig">Fig. 5</xref>, and again show that linear addition and subtraction of displacement fields is not appropriate. Also, some parts of the deformation fields had negative Jacobian determinants, which show the one-to-one mapping breaking down. The resulting deformation fields from Eq. <xref rid="fo0175" ref-type="disp-formula">(35)</xref> are more suited to some morphometric applications than those of <xref rid="fo0170" ref-type="disp-formula">(34)</xref>.</p>
          <p><xref rid="f0030" ref-type="fig">Fig. 6</xref> shows the parameters of the various models, illustrating the fact that the shooting method aligns shape information with the template image. For morphometric applications, where images of multiple subjects are aligned to a common template, this alignment of information should lead to a more parsimonious representation when using approaches such as principal component analysis.</p>
        </sec>
      </sec>
      <sec id="s0045">
        <title>Comparison with human expert segmentation</title>
        <p>Evaluation was performed using similar procedures to those of <xref rid="bb0100" ref-type="bibr">Klein et al. (2009)</xref>, and involved two datasets that are publicly available. Although these datasets do not provide absolute ground truth, they do allow automated methods to be compared against human experts. All the subjects’ scans have manually defined labels associated with them, which enables a comparison between manual and automatic structure labelling. For each of the datasets, the procedure involved aligning all the MR scans together (without using knowledge of the structure labels), and assessing how close the alignment is by warping each subject's structure labels into alignment with each other subject's labels. Overlap measures are most meaningful when compared with those achieved by other approaches, so the reader is referred to <xref rid="bb0100" ref-type="bibr">Klein et al. (2009)</xref> for reports of the “target overlap” measures from 15 other inter-subject registration algorithms. The measure is defined by the volume over which the deformed source labels match the target labels, divided by the total volume of the target labels.</p>
        <p>In the Klein paper, registration was done in a pairwise manner. In this evaluation, registration is between each individual in a dataset and the common average shaped template for that dataset. Rather than aligning the images themselves, the registration aligned tissue class data, and assumed that the tissue images of each subject are drawn from a multinomial distribution, whose mean is represented by a deformed version of the template (<xref rid="bb0035" ref-type="bibr">Ashburner and Friston, 2009</xref>). For <italic>M</italic> tissue classes, over <italic>I</italic> voxels, the objective function to minimise for one image is:<disp-formula id="fo0175"><label>(35)</label><mml:math id="M67" altimg="si88.gif" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo>=</mml:mo><mml:malignmark/><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>−</mml:mo><mml:mstyle><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>I</mml:mi></mml:munderover></mml:mstyle><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">J</mml:mi></mml:mstyle><mml:mn>1</mml:mn><mml:mi>φ</mml:mi></mml:msubsup><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover></mml:mstyle><mml:mspace width="0.12em"/><mml:msub><mml:mi>f</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mi>φ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mtext>log</mml:mtext><mml:msub><mml:mi>μ</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>The tissue class images were automatically derived via the “new segmentation” algorithm in SPM8 (<xref rid="bb0030" ref-type="bibr">Ashburner and Friston, 2005</xref>). Default settings were used for the tissue segmentation, except that a non-parametric representation of the tissue intensity distributions was used, rather than the default mixture of Gaussians. The tissue class images used for estimating the deformations were at an isotropic resolution of 1.5 mm.</p>
        <p>Following tissue classification, the diffeomorphic registration was repeated using two different regularisation settings.<xref rid="fn0005" ref-type="fn">1</xref> An elastic operator was used in both cases, as defined by:<disp-formula id="fo0180"><label>(36)</label><alternatives><textual-form specific-use="jats-markup">||<bold>L</bold><bold>v</bold>||<sup>2</sup> = ∫<sub><bold>x</bold> ∈ <italic>Ω</italic></sub> (¼||<bold>D</bold><bold>v</bold> + (<bold>D</bold><bold>v</bold>)<sup><italic>T</italic></sup>||<sup>2</sup> + <italic>λ</italic><sub>2</sub>||tr(<bold>D</bold><bold>v</bold>)||<sup>2</sup> + <italic>λ</italic><sub>3</sub>||<bold>v</bold>||<sup>2</sup>)<italic>d</italic><bold>x</bold></textual-form><mml:math id="M68" altimg="si89.gif" overflow="scroll"><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mstyle><mml:msub><mml:mo>∫</mml:mo><mml:mrow><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle><mml:mo>∈</mml:mo><mml:mi>Ω</mml:mi></mml:mrow></mml:msub></mml:mstyle><mml:mspace width="0.12em"/><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:msub><mml:mi>λ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mn>4</mml:mn></mml:mfrac><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">D</mml:mi><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">D</mml:mi><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mtext>tr</mml:mtext><mml:mo stretchy="true">(</mml:mo><mml:mstyle><mml:mi mathvariant="bold">D</mml:mi><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="true">|</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:mstyle><mml:mi mathvariant="bold">v</mml:mi></mml:mstyle><mml:mo stretchy="true">|</mml:mo><mml:msup><mml:mo stretchy="true">|</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mstyle><mml:mi mathvariant="bold">x</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>The three hyper-parameters control the following:<list list-type="simple"><list-item><label>•</label><p><italic>λ</italic><sub>1</sub> penalises the amount of stretching and shearing (but not rotation).</p></list-item><list-item><label>•</label><p><italic>λ</italic><sub>2</sub> controls the divergence of the initial velocity, which in turn determines the amount of volumetric expansion and contraction.</p></list-item><list-item><label>•</label><p><italic>λ</italic><sub>3</sub> simply penalises absolute displacements. It is included to ensure the uniqueness of the resulting <bold>K</bold> operator.</p></list-item></list></p>
        <p>The settings used were <italic>λ</italic><sub>1</sub> = 1.0, <italic>λ</italic><sub>2</sub> = 0.5, <italic>λ</italic><sub>3</sub> = 0.001 (referred to as GS1 in the results tables) and <italic>λ</italic><sub>1</sub> = 0.5, <italic>λ</italic><sub>2</sub> = 1.0, <italic>λ</italic><sub>3</sub> = 0.001 (called GS2).</p>
        <p>A further set of registrations were also carried out, but using the one-parameter subgroup representation (<xref rid="bb0015 bb0020" ref-type="bibr">Arsigny et al., 2006, 2009</xref>) of Dartel (<xref rid="bb0025" ref-type="bibr">Ashburner, 2007</xref>), rather than GS. The overall procedure was identical to GS2, except for the parameterisation of the deformations.</p>
        <p>After registration, the results include a set of mappings from the template to each of the individuals. For the evaluation, mappings from each individual to each other individual were required, so that structure labels from each subject could be overlaid on images of all other subjects. These mappings were derived by composing the inverse of one mapping, with another mapping, and using the result to warp the structure labels from one subject into alignment with the anatomy of another.</p>
        <p>The first of the datasets was from the Internet Brain Segmentation Repository (IBSR) provided by the Center for Morphometric Analysis at Massachusetts General Hospital.<xref rid="fn0010" ref-type="fn">2</xref> They consist of 18 anonymised T1-weighted MR scans (subject, scanner and sequence information are unknown), on which 43 individual structures have been manually labelled. The registration was based on the simultaneous alignment of grey matter, white matter, CSF, bone and soft tissue.</p>
        <p>The second dataset is from the LONI Probabilistic Brain Atlas (LPBA40) (<xref rid="bb0140" ref-type="bibr">Shattuck et al., 2008</xref>)<xref rid="fn0015" ref-type="fn">3</xref> and consists of 40 skull-stripped T1-weighted images (with cerebellum and brain-stem removed), that have 56 structures manually delineated. Because the LPBA40 set had been closely skull-stripped, this registration was based only on simultaneous alignment of grey and white matter.</p>
        <p>The resulting target overlaps are shown in <xref rid="f0035" ref-type="fig">Fig. 7</xref>, and compare favourably with the best overlap results of <xref rid="bb0100" ref-type="bibr">Klein et al. (2009)</xref>. For the IBSR18 dataset, the mean and median overlaps were 0.573 and 0.577 respectively for GS1, and 0.590 and 0.594 for GS2. Mean and median overlaps from the Dartel approach were 0.586 and 0.591. The greatest median overlap reported by <xref rid="bb0100" ref-type="bibr">Klein et al. (2009)</xref> was about 0.55, whereas the overlap from an affine registration (<xref rid="bb0095" ref-type="bibr">Jenkinson et al., 2002</xref>) was 0.40. For IBSR40, the mean and median overlaps were 0.750 and 0.751 for GS1, and 0.751 and 0.753 respectively for GS2. Mean and median overlaps from the Dartel approach were 0.751 and 0.753, very similar to the results from GS2. The highest median overlap reported by <xref rid="bb0100" ref-type="bibr">Klein et al. (2009)</xref> was 0.73, and that from affine registration was 0.60.</p>
        <p>For these data, the overlaps obtained from the GS approach are not much greater than those obtained from Dartel. The principal reason for this is that the nonlinear displacements were all relatively small (less than about 8.5 voxels anywhere in any of the brains) because the data had first been affine registered together. Evaluations with larger displacements are presented later in the paper.</p>
        <p>Using the affine registration as a baseline, the results showed 15% to 20% greater accuracy improvements<xref rid="fn0020" ref-type="fn">4</xref> when compared to those achieved for the most accurate of the nonlinear registration algorithms evaluated previously. These evaluations also showed that relatively small changes to the operator used to regularise the registration, can impact the final accuracies. Further exploration of the types of operators used, along with their various possible settings, could probably yield greater registration accuracy, but this was not the main aim of this work. Average overlaps (GS2) are shown for different brain structures<xref rid="fn0025" ref-type="fn">5</xref> in <xref rid="f0040 f0045" ref-type="fig">Figs. 8 and 9</xref>. Again, the plots show reasonably good overlap for the current method, compared to the best of the other algorithms.</p>
        <p>There are some aspects of this evaluation, which some may claim do not provide a fair comparison against other methods. The first of these is that a group-wise registration scheme was used, and that this may have some “unfair” advantage over pairwise alignments. Certainly, there are advantages in terms of internal consistency among all the deformations, as well as execution times. However, as the main aim of inter-subject alignment is to align groups of subjects together, it would seem reasonable to try to achieve this using the most accurate strategy possible. Because the Dartel results were very similar to those from GS, the accuracy improvements demonstrated here seemed largely a result of the groupwise registration of tissue class images, rather than the way the deformations were parameterised.</p>
        <p>The second potential criticism may be that the evaluations were done by the authors, rather than an “impartial” investigator. Occasionally, evaluations by other parties may be more about the competence of the investigator to run the approach, rather than of the algorithms themselves. As the alignments were based on matching tissue classes together, the output from the initial segmentations were visually examined beforehand, as these have a strong influence on the final results. In practice though, the algorithms were not adjusted in order to increase the accuracy for these particular datasets, and everything was run without any manual adjustments of the data (such as manual re-orienting). <xref rid="f0050 f0055" ref-type="fig">Figs. 10 and 11</xref> show the templates resulting from the two datasets after registration.</p>
      </sec>
      <sec id="s0050">
        <title>Evaluation of convergence in 3D</title>
        <p>One of the benefits of optimisation strategies that use second, as well as first, derivatives (such as Gauss–Newton or Levenberg–Marquardt) is that convergence is often much faster than approaches that use only the first derivatives (such as gradient descent). Here, convergence is assessed by plotting the value of the objective function with each iteration of the algorithm.</p>
        <p>In the previous subsection, a coarse-to-fine strategy was used, with the aim of avoiding some of the potential local minima. In this section, there is no coarse-to-fine strategy and eight time steps are used for the integration of the deformations. The template (see <xref rid="f0050" ref-type="fig">Fig. 10</xref>) and regularisation were fixed to that used for the final iterations in the evaluations in the previous section. The convergence for each of the subjects in the LPBA40 dataset was assessed, and plots of the objective function for each iteration are shown in <xref rid="f0060" ref-type="fig">Fig. 12</xref>.</p>
        <p>The <italic>L</italic><sub>2</sub> norm of the objective function gradients also provide a measure of convergence, so these are plotted in <xref rid="f0065" ref-type="fig">Fig. 13</xref>. In theory, these gradients should approach zero at the solution. This situation is not quite achieved in practice using the pure Gauss–Newton procedure (with <italic>γ</italic> fixed at 1 in Eq. <xref rid="fo0145" ref-type="disp-formula">(29)</xref>). The most likely reason for this is that the data are sampled discretely in the space of the template, leading to aliasing of high spatial frequency signal. This can cause the updates to overshoot slightly, causing the parameters to “bounce around” slightly for some regions of the images. Regularisation of the form described earlier (by reducing <italic>γ</italic> in Eq. <xref rid="fo0145" ref-type="disp-formula">(29)</xref>) could have been used to ensure that these norms properly approach zero. This is not shown, as the aim was to demonstrate the behaviour with a pure Gauss–Newton algorithm.</p>
        <p>Gradient descent algorithms often require hundreds of iterations to achieve convergence. This component of the evaluation was intended to show that reasonable convergence may be achieved with about 10 iterations of a Gauss–Newton algorithm. Slightly more exact solutions may be achieved by decreasing the update steps, although more iterations may be required.</p>
        <p>Each iteration of the GS approach is slower than for many other registration algorithms. On a Dell Precision T3500,<xref rid="fn0030" ref-type="fn">6</xref> each iteration took 43 s, whereas a Gauss–Newton iteration of Dartel (with six squaring steps) takes 20 s. The algorithm is of a type that should allow straightforward parallelisation, so further improvements could be achieved by implementing the most computationally intensive steps on GPUs.</p>
      </sec>
      <sec id="s0055">
        <title>Evaluation with larger displacements</title>
        <p>In the previous evaluations, all subjects’ brains were relatively healthy and of similar ages, so the impacts of much larger displacements were not really investigated. Those evaluations also involved images that had been first aligned together via 12-parameter affine transforms. For morphometric applications, the aim is usually to consider both shape and size, in which case the registration may be initialised using a rigid-body alignment. To assess the effects of larger displacements, the IBSR40 images were all translated along the anterior-posterior direction by 12 mm (8 voxels), and re-registered with the template previously generated from un-translated versions of the data (GS2). The length of an adult human brain varies with a standard deviation of about 8 mm, so 12 mm may be a typical displacement required for nonlinear registration of rigidly aligned brains. Velocity fields resulting from the translated scans were compared with those estimated from un-translated data, quantifying similarities between parameterisations <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>w</bold><sub><italic>a</italic></sub></textual-form><mml:math id="M69" altimg="si90.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi>a</mml:mi></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>w</bold><sub><italic>b</italic></sub></textual-form><mml:math id="M70" altimg="si91.gif" overflow="scroll"><mml:msub><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi>b</mml:mi></mml:msub></mml:math></alternatives></inline-formula> using correlation coefficients computed by<disp-formula id="fo0185"><label>(37)</label><mml:math id="M71" altimg="si92.gif" overflow="scroll"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi mathvariant="italic">ab</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi>a</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi>b</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi>a</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:msqrt><mml:msqrt><mml:mrow><mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi>b</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mstyle><mml:mi mathvariant="bold">A</mml:mi></mml:mstyle><mml:msub><mml:mstyle><mml:mi mathvariant="bold">w</mml:mi></mml:mstyle><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>where <bold>A</bold> is the large sparse matrix encoding the operator <inline-formula><alternatives><textual-form specific-use="jats-markup"><bold>L</bold><sup>†</sup><bold>L</bold></textual-form><mml:math id="M72" altimg="si94.gif" overflow="scroll"><mml:mrow><mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle><mml:mo>†</mml:mo></mml:msup><mml:mstyle><mml:mi mathvariant="bold">L</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula>. To reduce the penalty against absolute displacements, the values of <italic>λ</italic><sub>1</sub>, <italic>λ</italic><sub>2</sub> and <italic>λ</italic><sub>3</sub> used were 0.5, 1.0 and 0.00001 respectively. These are the same as for GS2, but with a much lower value for <italic>λ</italic><sub>3</sub>. Registrations of displaced data were done twice: once with initial velocity estimates set uniformly to zero (to provide poor starting estimates), and once with them set uniformly to 8 voxels (providing good starting estimates). Because no coarse to fine strategy was used, the first experiment assesses the robustness of the alignments with respect to initial misregistration, whereas the second assesses the properties of the deformation model. For all cases, 20 Gauss–Newton iterations of the registration algorithm were used.</p>
        <p>The mean correlation coefficient between results from the GS approach done without translations, versus the results of GS2 (from the previous evaluations), was 0.98. Ignoring the fact that the regularisation was slightly different in terms of penalising absolute displacements, this result showed that the coarse-to-fine strategy only played a small role in the comparison with human expert segmentation.</p>
        <p>The mean correlation coefficient between results from the Dartel and GS approaches, using un-translated data was 0.84. This is a reasonably high correlation, which suggests that when displacements are small, results obtained by registering using Dartel or GS are reasonaby similar to each other. However, a comparison between registration results from un-translated and translated data tells a different story. Using uniformly zero starting estimates, the correlation coefficients for GS were 0.52, whereas those for Dartel were only 0.19. This showed a highly significant difference between the behaviour of the two approaches. No coarse-to-fine strategy was used for these registrations, so much of the difference is likely to result from getting cought in local optima. By repeating the registration with starting estimates that encode a uniform displacement of 12mm, many of these local minima were avoided. With closer starting estimates (of the sort that the coarse-to-fine approach may help provide), the correlation coefficients were increased to 0.98 and 0.47 for GS and Dartel respectively. These clearly indicate the superiority of formulating registration using the LDDMM or GS framework, rather than that of Dartel. A comparison between <xref rid="f0010" ref-type="fig">Fig. 2</xref> and the left-side panel of 5 illustrates where the discrepancies arise, and <xref rid="f0030" ref-type="fig">Fig. 6</xref> also illustrates the differing behaviours of the two models. <xref rid="f0070" ref-type="fig">Fig. 14</xref> shows divergences (trace of Jacobian tensors) of the various estimated velocity parameterisations for one subject (S40). The slice has an axial orientation and contains the anterior cingulate. The thing to observe from the figure is that the GS results are all more similar to each other than those from Dartel, and that the Dartel results from aligning translated scans (lower centre and lower right) shows a clear blurring along the directionof translation. The fact that Dartel may be less ideally suited for computational anatomy studies was mentioned in <xref rid="bb0025" ref-type="bibr">Ashburner (2007)</xref>.</p>
      </sec>
    </sec>
    <sec id="s0060">
      <title>Conclusions</title>
      <p>This work demonstrates that convergence of diffeomorphic registration can be speeded up with Gauss–Newton optimisation, and that the memory costs previously incurred by storing the entire sequence of velocity fields can be avoided. This overcomes some of the obstacles that currently hinder the widespread adoption of a more coherent computational anatomy framework. Although the alignment accuracy achieved from an implementation of this approach appears to be higher than that of other algorithms evaluated using the same datasets, further improvements in terms of the choice of differential operator etc should lead to even greater accuracy. The geodesic shooting algorithm is released as a toolbox for SPM8.<xref rid="fn0035" ref-type="fn">7</xref></p>
    </sec>
  </body>
  <back>
    <ref-list>
      <title>References</title>
      <ref id="bb0005">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Andersson</surname>
              <given-names>J.L.R.</given-names>
            </name>
            <name>
              <surname>Jenkinson</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Smith</surname>
              <given-names>S.M.</given-names>
            </name>
          </person-group>
          <chapter-title>Non-linear registration, aka spatial normalisation</chapter-title>
          <source>FMRIB Analysis Group Technical Reports: TR07JA02</source>
          <year>2007</year>
        </element-citation>
      </ref>
      <ref id="bb0010">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ardekani</surname>
              <given-names>B.A.</given-names>
            </name>
            <name>
              <surname>Braun</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Hutton</surname>
              <given-names>B.F.</given-names>
            </name>
            <name>
              <surname>Kanno</surname>
              <given-names>I.</given-names>
            </name>
            <name>
              <surname>Iida</surname>
              <given-names>H.</given-names>
            </name>
          </person-group>
          <article-title>A fully automatic multimodality image registration algorithm</article-title>
          <source>Journal of computer assisted tomography</source>
          <volume>190</volume>
          <issue>4</issue>
          <year>1995</year>
          <fpage>615</fpage>
          <pub-id pub-id-type="pmid">7622696</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0015">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Arsigny</surname>
              <given-names>V.</given-names>
            </name>
            <name>
              <surname>Commowick</surname>
              <given-names>O.</given-names>
            </name>
            <name>
              <surname>Pennec</surname>
              <given-names>X.</given-names>
            </name>
            <name>
              <surname>Ayache</surname>
              <given-names>N.</given-names>
            </name>
          </person-group>
          <chapter-title>A Log-Euclidean framework for statistics on diffeomorphisms</chapter-title>
          <source>Medical Image Computing and Computer-Assisted Intervention — MICCAI 2006</source>
          <year>2006</year>
          <fpage>924</fpage>
          <lpage>931</lpage>
        </element-citation>
      </ref>
      <ref id="bb0020">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Arsigny</surname>
              <given-names>V.</given-names>
            </name>
            <name>
              <surname>Commowick</surname>
              <given-names>O.</given-names>
            </name>
            <name>
              <surname>Ayache</surname>
              <given-names>N.</given-names>
            </name>
            <name>
              <surname>Pennec</surname>
              <given-names>X.</given-names>
            </name>
          </person-group>
          <article-title>A fast and log-Euclidean polyaffine framework for locally linear registration</article-title>
          <source>Journal of Mathematical Imaging and Vision</source>
          <volume>330</volume>
          <issue>2</issue>
          <year>2009</year>
          <fpage>222</fpage>
          <lpage>238</lpage>
        </element-citation>
      </ref>
      <ref id="bb0025">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ashburner</surname>
              <given-names>J.</given-names>
            </name>
          </person-group>
          <article-title>A fast diffeomorphic image registration algorithm</article-title>
          <source>Neuroimage</source>
          <volume>380</volume>
          <issue>1</issue>
          <year>2007</year>
          <fpage>95</fpage>
          <lpage>113</lpage>
          <pub-id pub-id-type="pmid">17761438</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0030">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ashburner</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Friston</surname>
              <given-names>K.J.</given-names>
            </name>
          </person-group>
          <article-title>Unified segmentation</article-title>
          <source>Neuroimage</source>
          <volume>260</volume>
          <issue>3</issue>
          <year>2005</year>
          <fpage>839</fpage>
          <lpage>851</lpage>
          <pub-id pub-id-type="pmid">15955494</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0035">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ashburner</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Friston</surname>
              <given-names>K.J.</given-names>
            </name>
          </person-group>
          <article-title>Computing average shaped tissue probability templates</article-title>
          <source>NeuroImage</source>
          <volume>450</volume>
          <issue>2</issue>
          <year>2009</year>
          <fpage>333</fpage>
          <lpage>341</lpage>
          <pub-id pub-id-type="pmid">19146961</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0040">
        <mixed-citation publication-type="other">Ashburner, J., Klöppel, S., 2010. Multivariate models of inter-subject anatomical variability. NeuroImage.</mixed-citation>
      </ref>
      <ref id="bb0045">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Avants</surname>
              <given-names>B.B.</given-names>
            </name>
            <name>
              <surname>Epstein</surname>
              <given-names>C.L.</given-names>
            </name>
            <name>
              <surname>Grossman</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Gee</surname>
              <given-names>J.C.</given-names>
            </name>
          </person-group>
          <article-title>Symmetric diffeomorphic image registration with cross-correlation: evaluating automated labeling of elderly and neurodegenerative brain</article-title>
          <source>Medical image analysis</source>
          <volume>120</volume>
          <issue>1</issue>
          <year>2008</year>
          <fpage>26</fpage>
          <lpage>41</lpage>
          <pub-id pub-id-type="pmid">17659998</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0050">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Beg</surname>
              <given-names>M.F.</given-names>
            </name>
            <name>
              <surname>Miller</surname>
              <given-names>M.I.</given-names>
            </name>
            <name>
              <surname>Trouvé</surname>
              <given-names>A.</given-names>
            </name>
            <name>
              <surname>Younes</surname>
              <given-names>L.</given-names>
            </name>
          </person-group>
          <article-title>Computing large deformation metric mappings via geodesic flows of diffeomorphisms</article-title>
          <source>International Journal of Computer Vision</source>
          <volume>610</volume>
          <issue>2</issue>
          <year>2005</year>
          <fpage>139</fpage>
          <lpage>157</lpage>
        </element-citation>
      </ref>
      <ref id="bb0055">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Chiang</surname>
              <given-names>M.C.</given-names>
            </name>
            <name>
              <surname>Dutton</surname>
              <given-names>R.A.</given-names>
            </name>
            <name>
              <surname>Hayashi</surname>
              <given-names>K.M.</given-names>
            </name>
            <name>
              <surname>Lopez</surname>
              <given-names>O.L.</given-names>
            </name>
            <name>
              <surname>Aizenstein</surname>
              <given-names>H.J.</given-names>
            </name>
            <name>
              <surname>Toga</surname>
              <given-names>A.W.</given-names>
            </name>
            <name>
              <surname>Becker</surname>
              <given-names>J.T.</given-names>
            </name>
            <name>
              <surname>Thompson</surname>
              <given-names>P.M.</given-names>
            </name>
          </person-group>
          <article-title>3D pattern of brain atrophy in HIV/AIDS visualized using tensor-based morphometry</article-title>
          <source>Neuroimage</source>
          <volume>340</volume>
          <issue>1</issue>
          <year>2007</year>
          <fpage>44</fpage>
          <lpage>60</lpage>
          <pub-id pub-id-type="pmid">17035049</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0060">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Christensen</surname>
              <given-names>G.E.</given-names>
            </name>
            <name>
              <surname>Rabbitt</surname>
              <given-names>R.D.</given-names>
            </name>
            <name>
              <surname>Miller</surname>
              <given-names>M.I.</given-names>
            </name>
            <name>
              <surname>Joshi</surname>
              <given-names>S.C.</given-names>
            </name>
            <name>
              <surname>Grenander</surname>
              <given-names>U.</given-names>
            </name>
            <name>
              <surname>Coogan</surname>
              <given-names>T.A.</given-names>
            </name>
            <name>
              <surname>Van Essen</surname>
              <given-names>D.C.</given-names>
            </name>
          </person-group>
          <chapter-title>Topological properties of smooth anatomic maps</chapter-title>
          <source>Information processing in medical imaging</source>
          <year>1995</year>
          <fpage>101</fpage>
          <lpage>112</lpage>
        </element-citation>
      </ref>
      <ref id="bb0065">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Christensen</surname>
              <given-names>G.E.</given-names>
            </name>
            <name>
              <surname>Rabbitt</surname>
              <given-names>R.D.</given-names>
            </name>
            <name>
              <surname>Miller</surname>
              <given-names>M.I.</given-names>
            </name>
          </person-group>
          <article-title>Deformable templates using large deformation kinematics</article-title>
          <source>IEEE transactions on image processing</source>
          <volume>50</volume>
          <issue>10</issue>
          <year>1996</year>
          <fpage>1435</fpage>
          <lpage>1447</lpage>
          <pub-id pub-id-type="pmid">18290061</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0070">
        <mixed-citation publication-type="other">Cotter, C.J., Holm, D.D. Singular solutions, momentum maps and computational anatomy. Arxiv preprint nlin.SI/0605020, 2006.</mixed-citation>
      </ref>
      <ref id="bb0075">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Fischl</surname>
              <given-names>B.</given-names>
            </name>
            <name>
              <surname>Rajendran</surname>
              <given-names>N.</given-names>
            </name>
            <name>
              <surname>Busa</surname>
              <given-names>E.</given-names>
            </name>
            <name>
              <surname>Augustinack</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Hinds</surname>
              <given-names>O.</given-names>
            </name>
            <name>
              <surname>Yeo</surname>
              <given-names>B.T.</given-names>
            </name>
            <name>
              <surname>Mohlberg</surname>
              <given-names>H.</given-names>
            </name>
            <name>
              <surname>Amunts</surname>
              <given-names>K.</given-names>
            </name>
            <name>
              <surname>Zilles</surname>
              <given-names>K.</given-names>
            </name>
          </person-group>
          <article-title>Cortical folding patterns and predicting cytoarchitecture</article-title>
          <source>Cerebral Cortex</source>
          <volume>18</volume>
          <issue>8</issue>
          <year>2008</year>
          <fpage>1973</fpage>
          <lpage>1980</lpage>
          <pub-id pub-id-type="pmid">18079129</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0080">
        <mixed-citation publication-type="other">Ghosh, S.S., Kakunoori, S., Augustinack, J., Nieto-Castanon, A., Kovelman, I., Gaab, N., Christodoulou, J.A., Triantafyllou, C., Gabrieli, J.D.E., Fischl, B., 2010. Evaluating the validity of volume-based and surface-based brain image registration for developmental cognitive neuroscience studies in children 4-to-11 years of age. NeuroImage 53 (1), 85–93.</mixed-citation>
      </ref>
      <ref id="bb0085">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Grenander</surname>
              <given-names>U.</given-names>
            </name>
            <name>
              <surname>Miller</surname>
              <given-names>M.</given-names>
            </name>
          </person-group>
          <chapter-title>Pattern theory: from representation to inference</chapter-title>
          <year>2007</year>
          <publisher-name>Oxford University Press</publisher-name>
          <publisher-loc>USA</publisher-loc>
        </element-citation>
      </ref>
      <ref id="bb0090">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Holm</surname>
              <given-names>D.D.</given-names>
            </name>
            <name>
              <surname>Schmah</surname>
              <given-names>T.</given-names>
            </name>
            <name>
              <surname>Stoica</surname>
              <given-names>C.</given-names>
            </name>
          </person-group>
          <chapter-title>Geometric Mechanics and Symmetry: From Finite to Infinite Dimensions</chapter-title>
          <year>2009</year>
          <publisher-name>Oxford University Press</publisher-name>
          <publisher-loc>USA</publisher-loc>
        </element-citation>
      </ref>
      <ref id="bb0095">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Jenkinson</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Bannister</surname>
              <given-names>P.</given-names>
            </name>
            <name>
              <surname>Brady</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Smith</surname>
              <given-names>S.</given-names>
            </name>
          </person-group>
          <article-title>Improved optimization for the robust and accurate linear registration and motion correction of brain images</article-title>
          <source>Neuroimage</source>
          <volume>170</volume>
          <issue>2</issue>
          <year>2002</year>
          <fpage>825</fpage>
          <lpage>841</lpage>
          <pub-id pub-id-type="pmid">12377157</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0100">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Klein</surname>
              <given-names>A.</given-names>
            </name>
            <name>
              <surname>Andersson</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Ardekani</surname>
              <given-names>B.A.</given-names>
            </name>
            <name>
              <surname>Ashburner</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Avants</surname>
              <given-names>B.</given-names>
            </name>
            <name>
              <surname>Chiang</surname>
              <given-names>M.C.</given-names>
            </name>
            <name>
              <surname>Christensen</surname>
              <given-names>G.E.</given-names>
            </name>
            <name>
              <surname>Collins</surname>
              <given-names>D.L.</given-names>
            </name>
            <name>
              <surname>Gee</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Hellier</surname>
              <given-names>P.</given-names>
            </name>
          </person-group>
          <article-title>Evaluation of 14 nonlinear deformation algorithms applied to human brain MRI registration</article-title>
          <source>Neuroimage</source>
          <volume>460</volume>
          <issue>3</issue>
          <year>2009</year>
          <fpage>786</fpage>
          <lpage>802</lpage>
          <pub-id pub-id-type="pmid">19195496</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0105">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Klein</surname>
              <given-names>A.</given-names>
            </name>
            <name>
              <surname>Ghosh</surname>
              <given-names>S.S.</given-names>
            </name>
            <name>
              <surname>Avants</surname>
              <given-names>B.</given-names>
            </name>
            <name>
              <surname>Yeo</surname>
              <given-names>B.T.T.</given-names>
            </name>
            <name>
              <surname>Fischl</surname>
              <given-names>B.</given-names>
            </name>
            <name>
              <surname>Ardekani</surname>
              <given-names>B.</given-names>
            </name>
            <name>
              <surname>Gee</surname>
              <given-names>J.C.</given-names>
            </name>
            <name>
              <surname>Mann</surname>
              <given-names>J.J.</given-names>
            </name>
            <name>
              <surname>Parsey</surname>
              <given-names>R.V.</given-names>
            </name>
          </person-group>
          <article-title>Evaluation of volume-based and surface-based brain image registration methods</article-title>
          <source>NeuroImage</source>
          <volume>510</volume>
          <issue>1</issue>
          <year>2010</year>
          <fpage>214</fpage>
          <lpage>220</lpage>
          <pub-id pub-id-type="pmid">20123029</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0110">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Kriegl</surname>
              <given-names>A.</given-names>
            </name>
            <name>
              <surname>Michor</surname>
              <given-names>P.W.</given-names>
            </name>
          </person-group>
          <chapter-title>The convenient setting of global analysis</chapter-title>
          <year>1997</year>
          <publisher-name>Amer Mathematical Society</publisher-name>
          <comment>ISBN 0821807803</comment>
        </element-citation>
      </ref>
      <ref id="bb0115">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Marsland</surname>
              <given-names>S.</given-names>
            </name>
            <name>
              <surname>McLachlan</surname>
              <given-names>R.</given-names>
            </name>
          </person-group>
          <article-title>A Hamiltonian particle method for diffeomorphic image registration</article-title>
          <source>Lecture Notes in Computer Science</source>
          <volume>4584</volume>
          <year>2007</year>
          <fpage>396</fpage>
        </element-citation>
      </ref>
      <ref id="bb0120">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Miller</surname>
              <given-names>M.I.</given-names>
            </name>
            <name>
              <surname>Trouvé</surname>
              <given-names>A.</given-names>
            </name>
            <name>
              <surname>Younes</surname>
              <given-names>L.</given-names>
            </name>
          </person-group>
          <article-title>Geodesic shooting for computational anatomy</article-title>
          <source>Journal of Mathematical Imaging and Vision</source>
          <volume>240</volume>
          <issue>2</issue>
          <year>2006</year>
          <fpage>209</fpage>
          <lpage>228</lpage>
          <pub-id pub-id-type="pmid">20613972</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0125">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Modersitzki</surname>
              <given-names>J.</given-names>
            </name>
          </person-group>
          <chapter-title>FAIR: flexible algorithms for image registration</chapter-title>
          <year>2009</year>
          <publisher-name>Society for Industrial and Applied Mathematics (SIAM)</publisher-name>
        </element-citation>
      </ref>
      <ref id="bb0130">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Moler</surname>
              <given-names>C.</given-names>
            </name>
            <name>
              <surname>Van Loan</surname>
              <given-names>C.</given-names>
            </name>
          </person-group>
          <chapter-title>Nineteen dubious ways to compute the exponential of a matrix, twenty-five years later</chapter-title>
          <source>SIAM review</source>
          <year>2003</year>
          <fpage>3</fpage>
          <lpage>49</lpage>
        </element-citation>
      </ref>
      <ref id="bb0135">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Rueckert</surname>
              <given-names>D.</given-names>
            </name>
            <name>
              <surname>Aljabar</surname>
              <given-names>P.</given-names>
            </name>
            <name>
              <surname>Heckemann</surname>
              <given-names>R.</given-names>
            </name>
            <name>
              <surname>Hajnal</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Hammers</surname>
              <given-names>A.</given-names>
            </name>
          </person-group>
          <chapter-title>Diffeomorphic registration using B-splines</chapter-title>
          <source>Medical Image Computing and Computer-Assisted Intervention — MICCAI 2006</source>
          <year>2006</year>
          <fpage>702</fpage>
          <lpage>709</lpage>
        </element-citation>
      </ref>
      <ref id="bb0140">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Shattuck</surname>
              <given-names>D.W.</given-names>
            </name>
            <name>
              <surname>Mirza</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Adisetiyo</surname>
              <given-names>V.</given-names>
            </name>
            <name>
              <surname>Hojatkashani</surname>
              <given-names>C.</given-names>
            </name>
            <name>
              <surname>Salamon</surname>
              <given-names>G.</given-names>
            </name>
            <name>
              <surname>Narr</surname>
              <given-names>K.L.</given-names>
            </name>
            <name>
              <surname>Poldrack</surname>
              <given-names>R.A.</given-names>
            </name>
            <name>
              <surname>Bilder</surname>
              <given-names>R.M.</given-names>
            </name>
            <name>
              <surname>Toga</surname>
              <given-names>A.W.</given-names>
            </name>
          </person-group>
          <article-title>Construction of a 3D probabilistic atlas of human cortical structures</article-title>
          <source>NeuroImage</source>
          <volume>390</volume>
          <issue>3</issue>
          <year>2008</year>
          <fpage>1064</fpage>
          <lpage>1080</lpage>
          <pub-id pub-id-type="pmid">18037310</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0145">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Wang</surname>
              <given-names>L.</given-names>
            </name>
            <name>
              <surname>Beg</surname>
              <given-names>F.</given-names>
            </name>
            <name>
              <surname>Ratnanather</surname>
              <given-names>T.</given-names>
            </name>
            <name>
              <surname>Ceritoglu</surname>
              <given-names>C.</given-names>
            </name>
            <name>
              <surname>Younes</surname>
              <given-names>L.</given-names>
            </name>
            <name>
              <surname>Morris</surname>
              <given-names>J.C.</given-names>
            </name>
            <name>
              <surname>Csernansky</surname>
              <given-names>J.G.</given-names>
            </name>
            <name>
              <surname>Miller</surname>
              <given-names>M.I.</given-names>
            </name>
          </person-group>
          <article-title>Large deformation diffeomorphism and momentum based hippocampal shape discrimination in dementia of the Alzheimer type</article-title>
          <source>IEEE Transactions on Medical Imaging</source>
          <volume>260</volume>
          <issue>4</issue>
          <year>2007</year>
          <fpage>462</fpage>
          <lpage>470</lpage>
          <pub-id pub-id-type="pmid">17427733</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0150">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Yeo</surname>
              <given-names>B.T.T.</given-names>
            </name>
            <name>
              <surname>Sabuncu</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Mohlberg</surname>
              <given-names>H.</given-names>
            </name>
            <name>
              <surname>Amunts</surname>
              <given-names>K.</given-names>
            </name>
            <name>
              <surname>Zilles</surname>
              <given-names>K.</given-names>
            </name>
            <name>
              <surname>Golland</surname>
              <given-names>P.</given-names>
            </name>
            <name>
              <surname>Fischl</surname>
              <given-names>B.</given-names>
            </name>
          </person-group>
          <chapter-title>What data to co-register for computing atlases</chapter-title>
          <source>Proceedings of the International Conference on Computer Vision, IEEE Computer Society Workshop on Mathematical Methods in Biomedical Image Analysis</source>
          <year>2007</year>
        </element-citation>
      </ref>
      <ref id="bb0155">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Younes</surname>
              <given-names>L.</given-names>
            </name>
          </person-group>
          <article-title>Jacobi fields in groups of diffeomorphisms and applications</article-title>
          <source>Quarterly of Applied Mathematics</source>
          <volume>650</volume>
          <issue>1</issue>
          <year>2007</year>
          <fpage>113</fpage>
          <lpage>134</lpage>
        </element-citation>
      </ref>
      <ref id="bb0160">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Younes</surname>
              <given-names>L.</given-names>
            </name>
          </person-group>
          <chapter-title>Shapes and Diffeomorphisms, volume 171 of Applied Mathematical Sciences</chapter-title>
          <year>2010</year>
          <publisher-name>Springer-Verlag</publisher-name>
          <publisher-loc>Berlin and Heidelberg</publisher-loc>
        </element-citation>
      </ref>
      <ref id="bb0165">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Younes</surname>
              <given-names>L.</given-names>
            </name>
            <name>
              <surname>Qiu</surname>
              <given-names>A.</given-names>
            </name>
            <name>
              <surname>Winslow</surname>
              <given-names>R.L.</given-names>
            </name>
            <name>
              <surname>Miller</surname>
              <given-names>M.I.</given-names>
            </name>
          </person-group>
          <article-title>Transport of relational structures in groups of diffeomorphisms</article-title>
          <source>Journal of Mathematical Imaging and Vision</source>
          <volume>320</volume>
          <issue>1</issue>
          <year>2008</year>
          <fpage>41</fpage>
          <lpage>56</lpage>
          <pub-id pub-id-type="pmid">19809583</pub-id>
        </element-citation>
      </ref>
      <ref id="bb0170">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Younes</surname>
              <given-names>L.</given-names>
            </name>
            <name>
              <surname>Arrate</surname>
              <given-names>F.</given-names>
            </name>
            <name>
              <surname>Miller</surname>
              <given-names>M.I.</given-names>
            </name>
          </person-group>
          <article-title>Evolutions equations in computational anatomy</article-title>
          <source>Neuroimage</source>
          <volume>450</volume>
          <issue>1S1</issue>
          <year>2009</year>
          <fpage>40</fpage>
          <lpage>50</lpage>
        </element-citation>
      </ref>
    </ref-list>
    <ack>
      <title>Acknowledgments</title>
      <p>JA and KJF are funded by the Wellcome Trust. JA is grateful for helpful discussions with Alain Trouvé and Sarang Joshi, as well as to the community of investigators who make their data available for such work.</p>
    </ack>
    <fn-group>
      <fn id="fn0005">
        <label>1</label>
        <p>No other settings were tried.</p>
      </fn>
      <fn id="fn0010">
        <label>2</label>
        <p>Data available via <ext-link ext-link-type="uri" xlink:href="http://www.cma.mgh.harvard.edu/ibsr/">http://www.cma.mgh.harvard.edu/ibsr/</ext-link>.</p>
      </fn>
      <fn id="fn0015">
        <label>3</label>
        <p>Data available via <ext-link ext-link-type="uri" xlink:href="http://www.loni.ucla.edu/Atlases/Atlas_Detail.jsp?atlas_id=12">http://www.loni.ucla.edu/Atlases/Atlas_Detail.jsp?atlas_id=12</ext-link>.</p>
      </fn>
      <fn id="fn0020">
        <label>4</label>
        <p>(0.594 − 0.55)/(0.594 − 0.40) × 100<italic>%</italic> = 22.7<italic>%</italic> and (0.753 − 0.73)/(0.753 − 0.60) × 100<italic>%</italic> = 15.0<italic>%</italic>.</p>
      </fn>
      <fn id="fn0025">
        <label>5</label>
        <p>Overlap measures for other algorithms were obtained by dividing values in <ext-link ext-link-type="uri" xlink:href="http://www.mindboggle.info/papers/evaluation_NeuroImage2009/tables/table_ROIxMethod_TO_LPBA40.csv">http://www.mindboggle.info/papers/evaluation_NeuroImage2009/tables/table_ROIxMethod_TO_LPBA40.csv</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://www.mindboggle.info/papers/evaluation_NeuroImage2009/tables/table_ROIxMethod_TO_IBSR18.csv">http://www.mindboggle.info/papers/evaluation_NeuroImage2009/tables/table_ROIxMethod_TO_IBSR18.csv</ext-link> by 100.</p>
      </fn>
      <fn id="fn0030">
        <label>6</label>
        <p>MATLAB (R2009a) benchmarks: LU 0.27; FFT 0.24; ODE 0.20; Sparse 0.80.</p>
      </fn>
      <fn id="fn0035">
        <label>7</label>
        <p><ext-link ext-link-type="uri" xlink:href="http://www.fil.ion.ucl.ac.uk/spm/software/spm8/">www.fil.ion.ucl.ac.uk/spm/software/spm8/</ext-link>.</p>
      </fn>
    </fn-group>
  </back>
  <floats-group>
    <fig id="f0005">
      <label>Fig. 1</label>
      <caption>
        <p>The inverse of the elasticity operator, which is used for computing velocity from momentum (<bold>v</bold><sub><italic>t</italic></sub> = <bold>Ku</bold><sub><italic>t</italic></sub>). This is the Green's function (fundamental solution for a linear partial differential operator). Note that this figure shows a 2D version of the operator. Obtaining the <italic>x</italic> (horizontal) component of the velocity involves convolving the <italic>x</italic> component of the momentum with the function shown at the top left, and adding the <italic>y</italic> (vertical) component of the momentum, convolved with the function shown at the top right. Similarly, obtaining the velocity's <italic>y</italic> component is by convolving the momentum's <italic>x</italic> component with the lower-left function, and adding this to the momentum's <italic>y</italic> component convolved with the lower-right function.</p>
      </caption>
      <graphic xlink:href="gr1"/>
    </fig>
    <fig id="f0010">
      <label>Fig. 2</label>
      <caption>
        <p>Results of diffeomorphic registation of two simulated images. Original images (top row), registered images (2nd row), diffeomorphic deformations (3rd row) and Jacobian determinants (bottom).</p>
      </caption>
      <graphic xlink:href="gr2"/>
    </fig>
    <fig id="f0015">
      <label>Fig. 3</label>
      <caption>
        <p>Convergence of the Gauss–Newton optimisation. The top panel shows how the objective function is reduced at each iteration, whereas the lower panel shows the norm of the derivatives of the objective function with respect to the model parameters. At the exact solution (either globally or locally optimal), this norm should be zero.</p>
      </caption>
      <graphic xlink:href="gr3"/>
    </fig>
    <fig id="f0020">
      <label>Fig. 4</label>
      <caption>
        <p>Illustration of the evolution equations for computing diffeomorphisms. The top row shows the system at time zero, which is followed in successive rows at later time points. Note that only eight time points were used for this integration, and that images are scaled so that intensities range between the overall minimum and maximum values within each column. Darker regions indicate larger values.</p>
      </caption>
      <graphic xlink:href="gr4"/>
    </fig>
    <fig id="f0025">
      <label>Fig. 5</label>
      <caption>
        <p>Various other deformation model results. Left panel: registration using a log-Euclidean model (Eq. <xref rid="fo0165" ref-type="disp-formula">(33)</xref>). Centre panel: small-deformation of the template to the individual (Eq. <xref rid="fo0170" ref-type="disp-formula">(34)</xref>). Right panel: small-deformation of the individual to the template (Eq. <xref rid="fo0175" ref-type="disp-formula">(35)</xref>). Note that the Jacobian determinant images are shown scaled between their minimum and maximum values and that darker regions indicate larger values.</p>
      </caption>
      <graphic xlink:href="gr5"/>
    </fig>
    <fig id="f0030">
      <label>Fig. 6</label>
      <caption>
        <p>The velocity (left panel) and “momentum” (right panel) fields of the four models. The left column shows the horizontal component, whereas the right column shows the vertical component. The top row shows the initial velocities and momenta obtained using the shooting method. Velocities and momenta from the log-Euclidean method (Eq. <xref rid="fo0165" ref-type="disp-formula">(33)</xref>) are shown in the second row. Those from the small-deformation methods are shown in the third (Eq. <xref rid="fo0170" ref-type="disp-formula">(34)</xref>) and fourth (Eq. <xref rid="fo0175" ref-type="disp-formula">(35)</xref>) rows.</p>
      </caption>
      <graphic xlink:href="gr6"/>
    </fig>
    <fig id="f0035">
      <label>Fig. 7</label>
      <caption>
        <p>Volume overlap measures compare favourably with those obtained from the other registration algorithms evaluated in <xref rid="bb0100" ref-type="bibr">Klein et al. (2009)</xref> (this figure may be compared directly with Fig. 5 of that paper). On each box, the central mark is the median, the edges of the box are the 25th and 75th percentiles, the whiskers extend to the most extreme data-points not considered outliers. Any outliers are plotted individually.</p>
      </caption>
      <graphic xlink:href="gr7"/>
    </fig>
    <fig id="f0040">
      <label>Fig. 8</label>
      <caption>
        <p>Average volume overlap for each region in the LPBA40 dataset (GS2). Results from the current GS approach are shown with filled circles. Crosses indicate results from the four algorithms evaluated in <xref rid="bb0100" ref-type="bibr">Klein et al. (2009)</xref> that performed best for this dataset (ART (<xref rid="bb0010" ref-type="bibr">Ardekani et al., 1995</xref>), SyN (<xref rid="bb0045" ref-type="bibr">Avants and Epstein, 2008</xref>), FNIRT (<xref rid="bb0005" ref-type="bibr">Andersson et al., 2007</xref>) and JRD-fluid (<xref rid="bb0055" ref-type="bibr">Chiang et al., 2007</xref>)).</p>
      </caption>
      <graphic xlink:href="gr8"/>
    </fig>
    <fig id="f0045">
      <label>Fig. 9</label>
      <caption>
        <p>Average volume overlap for each region in the IBSR18 dataset (GS2). Results from the current GS approach are shown with filled circles. Crosses indicate results from the four algorithms evaluated in <xref rid="bb0100" ref-type="bibr">Klein et al. (2009)</xref> that performed best for this dataset (SPM_D (<xref rid="bb0025" ref-type="bibr">Ashburner, 2007</xref>), SyN (<xref rid="bb0045" ref-type="bibr">Avants and Epstein, 2008</xref>), IRTK (<xref rid="bb0135" ref-type="bibr">Rueckert et al., 2006</xref>) and ART (<xref rid="bb0010" ref-type="bibr">Ardekani et al., 1995</xref>)).</p>
      </caption>
      <graphic xlink:href="gr9"/>
    </fig>
    <fig id="f0050">
      <label>Fig. 10</label>
      <caption>
        <p>The LPBA40 tissue probability template, showing slices 40, 60 and 80 (GS2).</p>
      </caption>
      <graphic xlink:href="gr10"/>
    </fig>
    <fig id="f0055">
      <label>Fig. 11</label>
      <caption>
        <p>The IBSR tissue probability template, showing slices 40, 60 and 80 (GS2).</p>
      </caption>
      <graphic xlink:href="gr11"/>
    </fig>
    <fig id="f0060">
      <label>Fig. 12</label>
      <caption>
        <p>Objective function after different numbers of Gauss-Newton iterations, when matching the images in the LPBA40 dataset to their average.</p>
      </caption>
      <graphic xlink:href="gr12"/>
    </fig>
    <fig id="f0065">
      <label>Fig. 13</label>
      <caption>
        <p>The norm of the derivatives of the objective function after different numbers of Gauss–Newton iterations. In principle, the norm should be zero if the algorithm has fully converged.</p>
      </caption>
      <graphic xlink:href="gr13"/>
    </fig>
    <fig id="f0070">
      <label>Fig. 14</label>
      <caption>
        <p>A single slice through the divergence of velocity fields computed after registering one of the LPBA40 subjects. The top row shows results from registering via GS, whereas the bottom row shows results from using Dartel. Results from un-translated data are shown (left column), followed by results of translated images with poor starting estimates (middle column) and finally results from translated data with close starting estimates (right column).</p>
      </caption>
      <graphic xlink:href="gr14"/>
    </fig>
  </floats-group>
</article>