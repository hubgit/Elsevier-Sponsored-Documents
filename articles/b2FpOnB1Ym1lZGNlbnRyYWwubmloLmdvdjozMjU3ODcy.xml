<article xmlns="http://dtd.nlm.nih.gov/2.0/xsd/archivearticle" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://dtd.nlm.nih.gov/2.0/xsd/archivearticle http://dtd.nlm.nih.gov/2.0/xsd/archivearticle.xsd" article-type="research-article">
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-ta">J Comput Appl Math</journal-id>
      <journal-title-group>
        <journal-title>Journal of Computational and Applied Mathematics</journal-title>
      </journal-title-group>
      <issn pub-type="ppub">0377-0427</issn>
      <issn pub-type="epub">1879-1778</issn>
      <publisher>
        <publisher-name>Koninklijke Vlaamse Ingenieursvereniging</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmc">3257872</article-id>
      <article-id pub-id-type="pmid">22267893</article-id>
      <article-id pub-id-type="publisher-id">CAM8500</article-id>
      <article-id pub-id-type="doi">10.1016/j.cam.2011.09.011</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Article</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Theory, implementation and applications of nonstationary Gabor frames</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Balazs</surname>
            <given-names>P.</given-names>
          </name>
          <email>peter.balazs@oeaw.ac.at</email>
          <xref rid="af000005" ref-type="aff">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Dörfler</surname>
            <given-names>M.</given-names>
          </name>
          <email>monika.doerfler@univie.ac.at</email>
          <xref rid="af000010" ref-type="aff">b</xref>
          <xref rid="cor000005" ref-type="corresp">⁎</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Jaillet</surname>
            <given-names>F.</given-names>
          </name>
          <email>florent.jaillet@incm.cnrs-mrs.fr</email>
          <xref rid="af000015" ref-type="aff">c</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Holighaus</surname>
            <given-names>N.</given-names>
          </name>
          <email>nicki.holighaus@univie.ac.at</email>
          <xref rid="af000010" ref-type="aff">b</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Velasco</surname>
            <given-names>G.</given-names>
          </name>
          <email>gino.velasco@univie.ac.at</email>
          <xref rid="af000010" ref-type="aff">b</xref>
          <xref rid="af000020" ref-type="aff">d</xref>
        </contrib>
      </contrib-group>
      <aff id="af000005"><label>a</label>Acoustics Research Institute, Austrian Academy of Sciences, Wohllebengasse 12-14, 1040 Wien, Austria</aff>
      <aff id="af000010"><label>b</label>Numerical Harmonic Analysis Group, Faculty of Mathematics, University of Vienna, Alserbachstraße 23, 1090 Wien, Austria</aff>
      <aff id="af000015"><label>c</label>Institut de Neurosciences Cognitives de la Méditerranée, UMR 6193 CNRS - Université de la Méditerranée, 31 chemin Joseph Aiguier, 13402 Marseille cedex 20, France</aff>
      <aff id="af000020"><label>d</label>Institute of Mathematics, University of the Philippines - Diliman, 1101 Quezon City, Philippines</aff>
      <author-notes>
        <corresp id="cor000005"><label>⁎</label>Corresponding author. <email>monika.doerfler@univie.ac.at</email></corresp>
      </author-notes>
      <pub-date pub-type="pmc-release">
        <day>15</day>
        <month>10</month>
        <year>2011</year>
      </pub-date>
      <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="ppub"/>. -->
      <pub-date pub-type="ppub">
        <day>15</day>
        <month>10</month>
        <year>2011</year>
      </pub-date>
      <volume>236</volume>
      <issue>6</issue>
      <fpage>1481</fpage>
      <lpage>1496</lpage>
      <history>
        <date date-type="received">
          <day>22</day>
          <month>3</month>
          <year>2011</year>
        </date>
        <date date-type="rev-recd">
          <day>2</day>
          <month>9</month>
          <year>2011</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>© 2011 Elsevier B.V.</copyright-statement>
        <copyright-year>2011</copyright-year>
        <copyright-holder>Elsevier B.V.</copyright-holder>
        <license>
          <license-p>This document may be redistributed and reused, subject to <ext-link ext-link-type="uri" xlink:href="http://www.elsevier.com/wps/find/authorsview.authors/supplementalterms1.0">certain conditions</ext-link>.</license-p>
        </license>
      </permissions>
      <abstract>
        <p>Signal analysis with classical Gabor frames leads to a fixed time–frequency resolution over the whole time–frequency plane. To overcome the limitations imposed by this rigidity, we propose an extension of Gabor theory that leads to the construction of frames with time–frequency resolution changing over time or frequency. We describe the construction of the resulting <italic>nonstationary Gabor frames</italic> and give the explicit formula for the canonical dual frame for a particular case, the <italic>painless case</italic>. We show that wavelet transforms, constant-Q transforms and more general filter banks may be modeled in the framework of nonstationary Gabor frames. Further, we present the results in the finite-dimensional case, which provides a method for implementing the above-mentioned transforms with perfect reconstruction. Finally, we elaborate on two applications of nonstationary Gabor frames in audio signal processing, namely a method for automatic adaptation to transients and an algorithm for an invertible constant-Q transform.</p>
      </abstract>
      <kwd-group>
        <title>Keywords</title>
        <kwd>Time–frequency analysis</kwd>
        <kwd>Adaptive representation</kwd>
        <kwd>Constant-Q transform</kwd>
        <kwd>Invertibility</kwd>
      </kwd-group>
    </article-meta>
  </front>
  <body>
    <sec id="s000005">
      <label>1</label>
      <title>Introduction</title>
      <p>Redundant short-time Fourier methods, also known as Gabor analysis <xref rid="br000005" ref-type="bibr">[1]</xref>, are widely used in signal processing applications. The basic idea is the analysis of a signal <italic>f</italic> by consideration of the projections <inline-formula><alternatives><textual-form specific-use="jats-markup">〈<italic>f</italic>, <italic>g</italic><sub><italic>τ</italic>, <italic>ω</italic></sub>〉</textual-form><mml:math id="M1" altimg="si10.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> of <italic>f</italic> onto time–frequency atoms <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>τ</italic>, <italic>ω</italic></sub></textual-form><mml:math id="M2" altimg="si12.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ω</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. The <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>τ</italic>, <italic>ω</italic></sub></textual-form><mml:math id="M3" altimg="si13.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ω</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> are obtained by translation of a unique prototype function over time and frequency: <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>τ</italic>, <italic>ω</italic></sub>(<italic>t</italic>) = <italic>g</italic>(<italic>t</italic> − <italic>τ</italic>)<italic>e</italic><sup>2<italic>π</italic><italic>i</italic><italic>t</italic><italic>ω</italic></sup></textual-form><mml:math id="M4" altimg="si14.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>ω</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>. This classical construction leads to a signal decomposition with fixed time–frequency resolution over the whole time–frequency plane. The restriction to a fixed resolution is often undesirable in processing signals with variable time–frequency characteristics. Alternative decompositions have been introduced to overcome this deficit, e.g. the wavelet transform <xref rid="br000010" ref-type="bibr">[2]</xref>, the constant-Q transform (CQT) <xref rid="br000015" ref-type="bibr">[3]</xref> or decompositions using filter banks <xref rid="br000020" ref-type="bibr">[4]</xref>, in particular based on perceptive frequency scales <xref rid="br000025" ref-type="bibr">[5]</xref>. Adaptation over time is considered in approaches such as modulated lapped transforms <xref rid="br000030" ref-type="bibr">[6]</xref>, adapted local trigonometric transforms <xref rid="br000035" ref-type="bibr">[7]</xref> or (time-varying) wavelet packets <xref rid="br000040" ref-type="bibr">[8]</xref>.</p>
      <p>Most of the cited work achieves flexible tilings of the time–frequency plane, but efficient reconstruction from signal-adaptive, overcomplete time–frequency transforms is rarely addressed. One exception is a recent approach in <xref rid="br000045" ref-type="bibr">[9]</xref>, which is in fact a special case of the more general model considered in the present paper. The wealth of existing approaches to fast adaptive transforms underlines the need for flexibility arising from many applications. On the other hand, the introduction of flexibility in a transform that is based on accurate mathematical modeling causes technical complications that are not always easy to overcome. We introduce an approach to fast adaptive time–frequency transforms, that is based on a generalization of <italic>painless nonorthogonal expansions</italic> <xref rid="br000050" ref-type="bibr">[10]</xref>. It allows for adaptivity of the analysis windows <italic>and</italic> the sampling points. Since the resulting frames locally resemble classical Gabor frames and share some of their structure, they are called <italic>nonstationary Gabor frames</italic>. The corresponding transform is likewise referred to as <italic>nonstationary Gabor transform</italic> (NSGT).</p>
      <p>The central feature of painless expansions is the diagonality of the frame operator associated with the proposed analysis system. This idea is used here to yield painless nonstationary Gabor frames and will allow for both mathematical accuracy in the sense of perfect reconstruction (the frame operator is invertible) and numerical feasibility by means of an FFT-based implementation. The construction of painless nonstationary Gabor frames relies on three intuitively accessible properties of the windows and time–frequency shift parameters used. <list list-type="simple"><list-item><label>1.</label><p>The signal <italic>f</italic> of interest is localized at time- (or frequency-)positions <italic>n</italic> by means of multiplication with a <italic>compactly supported</italic> (or limited bandwidth, respectively) window function <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M5" altimg="si17.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>.</p></list-item><list-item><label>2.</label><p>The Fourier transform is applied on the localized pieces <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic> ⋅ <italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M6" altimg="si18.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. The resulting spectra are sampled densely enough in order to perfectly reconstruct <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic> ⋅ <italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M7" altimg="si19.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> from these samples.</p></list-item><list-item><label>3.</label><p>Adjacent windows overlap to avoid loss of information. At the same time, unnecessary overlap is undesirable. In other words, we assume that <inline-formula><alternatives><textual-form specific-use="jats-markup">0 &lt; <italic>A</italic> ≤ ∑ <sub><italic>n</italic> ∈ ℤ</sub>|<italic>g</italic><sub><italic>n</italic></sub>(<italic>t</italic>)|<sup>2</sup> ≤ <italic>B</italic> &lt; <italic>∞</italic></textual-form><mml:math id="M8" altimg="si20.gif" display="inline" overflow="scroll"><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>A</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≤</mml:mo><mml:mi>B</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>∞</mml:mi></mml:math></alternatives></inline-formula>, a.e., for some positive <italic>A</italic> and <italic>B</italic>.</p></list-item></list> We will show that these requirements lead to invertibility of the frame operator and therefore to perfect reconstruction. Moreover, the frame operator is diagonal and its inversion is straight-forward. Further, the canonical dual frame has the same structure as the original one. Because of these pleasant consequences following from the three above-mentioned requirements, the frames satisfying all of them will be called <italic>painless nonstationary Gabor frames</italic> and we refer to this situation as the <italic>painless case</italic>. Under application of a Fourier transform to the signal of interest, our approach leads to adaptivity in either time or frequency. The concept of this paper relies on ideas introduced in <xref rid="br000055" ref-type="bibr">[11]</xref>, and presented in <xref rid="br000060" ref-type="bibr">[12]</xref>. In the present paper all formal proofs are given, the link to frame theory is provided, the possibility to represent other analysis/synthesis systems with this approach is established, the numerical issues are investigated and several applications are presented.</p>
      <p>The rest of the article is organized as follows. We fix notation and review preliminary results from Gabor and frame theory in Section <xref rid="s000010" ref-type="sec">2</xref>. Section <xref rid="s000030" ref-type="sec">3</xref> introduces the construction of (painless) nonstationary Gabor frames in detail and provides a proof for the frame property under the given conditions. The calculation of the dual or tight frames is also explicitly given for systems adaptive in time or frequency, respectively. Section <xref rid="s000055" ref-type="sec">4</xref> then establishes the details of implementation in a discrete and real-life setting and provides examples together with a comparison of numerical efficiency with existing approaches. We conclude, in Section <xref rid="s000085" ref-type="sec">5</xref> with a summary and a brief outlook on future work.</p>
      <p>In the sense of reproducible research, <xref rid="br000065" ref-type="bibr">[13]</xref>, we provide all algorithms and scripts to reproduce the results in this paper at the webpage <ext-link ext-link-type="uri" xlink:href="http://univie.ac.at/nonstatgab/" id="ir000005">http://univie.ac.at/nonstatgab/</ext-link>. Please note that a nonstationary Gabor transform is also included in the Linear Time Frequency Analysis Toolbox (LTFAT) v.1.0 <xref rid="br000070 br000075" ref-type="bibr">[14,15]</xref>, a Matlab/Octave toolbox, which is freely available at <ext-link ext-link-type="uri" xlink:href="http://ltfat.sourceforge.net/" id="ir000010">http://ltfat.sourceforge.net/</ext-link>.</p>
    </sec>
    <sec id="s000010">
      <label>2</label>
      <title>Preliminaries</title>
      <p>For an integrable function <italic>f</italic>, i.e. <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic> ∈ <italic>L</italic><sup>1</sup>(ℝ)</textual-form><mml:math id="M9" altimg="si24.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, we denote its Fourier transform <inline-formula><mml:math id="M10" altimg="si25.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">F</mml:mi><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ξ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>ξ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.16667em"/><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>ξ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:math></inline-formula>, with the usual extension to <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M11" altimg="si26.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, the space of square-integrable functions from ℝ to ℂ. The convolution of two functions <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic>, <italic>g</italic> ∈ <italic>L</italic><sup>1</sup>(ℝ)</textual-form><mml:math id="M12" altimg="si29.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is the function <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic> ∗ <italic>g</italic></textual-form><mml:math id="M13" altimg="si30.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>∗</mml:mo><mml:mi>g</mml:mi></mml:math></alternatives></inline-formula> defined by <inline-formula><alternatives><textual-form specific-use="jats-markup">(<italic>f</italic> ∗ <italic>g</italic>)(<italic>t</italic>) = ∫<sub>ℝ</sub><italic>f</italic>(<italic>x</italic>)<italic>g</italic>(<italic>t</italic> − <italic>x</italic>) <italic>d</italic><italic>x</italic></textual-form><mml:math id="M14" altimg="si31.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>∗</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.16667em"/><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>, again with the usual extension to <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M15" altimg="si32.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. It follows that <inline-formula><mml:math id="M16" altimg="si33.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">F</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>∗</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover><mml:mo>⋅</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:math></inline-formula>. We use the notation <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic>(<italic>t</italic>) ≃ <italic>g</italic>(<italic>t</italic>)</textual-form><mml:math id="M17" altimg="si34.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>≃</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> if there exist constants <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>C</italic><sub>1</sub>, <italic>C</italic><sub>2</sub> &gt; 0</textual-form><mml:math id="M18" altimg="si35.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></alternatives></inline-formula>, such that <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>C</italic><sub>1</sub><italic>g</italic>(<italic>t</italic>) ≤ <italic>f</italic>(<italic>t</italic>) ≤ <italic>C</italic><sub>2</sub><italic>g</italic>(<italic>t</italic>)</textual-form><mml:math id="M19" altimg="si36.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> for all <italic>t</italic>.</p>
      <sec id="s000015">
        <label>2.1</label>
        <title>Frame theory</title>
        <p>We now give a short summary of frame theory on Hilbert spaces, first introduced in <xref rid="br000080" ref-type="bibr">[16]</xref>. A thorough discussion can be found in <xref rid="br000085" ref-type="bibr">[17]</xref> or <xref rid="br000090" ref-type="bibr">[18]</xref>.</p>
        <p>A sequence <inline-formula><alternatives><textual-form specific-use="jats-markup">(<italic>ψ</italic><sub><italic>l</italic></sub>)<sub><italic>l</italic> ∈ <italic>I</italic></sub></textual-form><mml:math id="M20" altimg="si38.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> in the Hilbert space ℋ is called a <italic>frame</italic>, if there exist positive constants <italic>A</italic> and <italic>B</italic> (called lower and upper frame bounds, respectively) such that <disp-formula id="fd000005"><label>(1)</label><mml:math id="M21" altimg="si42.gif" display="block" overflow="scroll"><mml:mi>A</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>f</mml:mi><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≤</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≤</mml:mo><mml:mi>B</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>f</mml:mi><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mspace width="1em" class="quad"/><mml:mi>∀</mml:mi><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mtext>,</mml:mtext></mml:math></disp-formula> i.e. <inline-formula><alternatives><textual-form specific-use="jats-markup">∑ <sub><italic>l</italic> ∈ <italic>I</italic></sub>|〈<italic>f</italic>, <italic>ψ</italic><sub><italic>l</italic></sub>〉|<sup>2</sup> ≃ ‖<italic>f</italic>‖<sup>2</sup></textual-form><mml:math id="M22" altimg="si43.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≃</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>f</mml:mi><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>. If <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>A</italic> = <italic>B</italic></textual-form><mml:math id="M23" altimg="si44.gif" display="inline" overflow="scroll"><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mi>B</mml:mi></mml:math></alternatives></inline-formula>, then <inline-formula><alternatives><textual-form specific-use="jats-markup">(<italic>ψ</italic><sub><italic>l</italic></sub>)<sub><italic>l</italic> ∈ <italic>I</italic></sub></textual-form><mml:math id="M24" altimg="si45.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> is a <italic>tight frame</italic>. By <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>C</italic>:ℋ → <italic>ℓ</italic><sup>2</sup></textual-form><mml:math id="M25" altimg="si46.gif" display="inline" overflow="scroll"><mml:mstyle mathvariant="bold"><mml:mi>C</mml:mi></mml:mstyle><mml:mo>:</mml:mo><mml:mi mathvariant="script">H</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>, we denote the <italic>analysis operator</italic> defined by <inline-formula><alternatives><textual-form specific-use="jats-markup">(<italic>C</italic><italic>f</italic>)<sub><italic>l</italic></sub> = 〈<italic>f</italic>, <italic>ψ</italic><sub><italic>l</italic></sub>〉</textual-form><mml:math id="M26" altimg="si47.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>C</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. The adjoint of <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>C</italic><sup> ∗ </sup></textual-form><mml:math id="M27" altimg="si48.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>C</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup></mml:math></alternatives></inline-formula> of <italic>C</italic> is the <italic>synthesis operator</italic> <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>C</italic><sup> ∗ </sup>(<italic>c</italic><sub><italic>l</italic></sub>) = ∑ <sub><italic>l</italic></sub><italic>c</italic><sub><italic>l</italic></sub><italic>ψ</italic><sub><italic>l</italic></sub></textual-form><mml:math id="M28" altimg="si50.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>C</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. The <italic>frame operator</italic> is <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>S</italic><italic>f</italic> = <italic>C</italic><sup> ∗ </sup><italic>C</italic><italic>f</italic> = ∑ <sub><italic>l</italic></sub>〈<italic>f</italic>, <italic>ψ</italic><sub><italic>l</italic></sub>〉<italic>ψ</italic><sub><italic>l</italic></sub></textual-form><mml:math id="M29" altimg="si51.gif" display="inline" overflow="scroll"><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>C</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup><mml:mstyle mathvariant="bold"><mml:mi>C</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, hence <inline-formula><mml:math id="M30" altimg="si52.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>C</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula>.</p>
        <p>The boundedness and invertibility of <italic>S</italic> is equivalent to the existence of frame bounds <inline-formula><alternatives><textual-form specific-use="jats-markup">0 &lt; <italic>A</italic>, <italic>B</italic> &lt; <italic>∞</italic></textual-form><mml:math id="M31" altimg="si54.gif" display="inline" overflow="scroll"><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>∞</mml:mi></mml:math></alternatives></inline-formula> in the frame inequality <xref rid="fd000005" ref-type="disp-formula">(1)</xref>, as well as to the existence of <italic>dual frames</italic>, which can be used for reconstruction. In particular, the <italic>canonical dual frame</italic> <inline-formula><mml:math id="M32" altimg="si55.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mo>˜</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>, is found by applying the inverse of <italic>S</italic> to the original frame elements, i.e. <inline-formula><mml:math id="M33" altimg="si57.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mo>˜</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> for all <italic>l</italic>. For all <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic> ∈ ℋ</textual-form><mml:math id="M34" altimg="si59.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">H</mml:mi></mml:math></alternatives></inline-formula> we then have the following reconstruction formulas: <disp-formula id="fd000010"><mml:math id="M35" altimg="si60.gif" display="block" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mo>˜</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mo>˜</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mtext>.</mml:mtext></mml:math></disp-formula> For tight frames, the frame operator reduces to <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>S</italic> = <italic>A</italic><italic>I</italic></textual-form><mml:math id="M36" altimg="si61.gif" display="inline" overflow="scroll"><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mstyle mathvariant="bold"><mml:mi>I</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>, where <italic>I</italic> denotes the identity operator, and therefore <inline-formula><mml:math id="M37" altimg="si63.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:mfrac><mml:mstyle mathvariant="bold"><mml:mi>I</mml:mi></mml:mstyle></mml:math></inline-formula>. The <italic>canonical tight frame</italic> <inline-formula><mml:math id="M38" altimg="si64.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mo>˚</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> is obtained by applying <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>S</italic><sup> − ½</sup></textual-form><mml:math id="M39" altimg="si65.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:math></alternatives></inline-formula> to the frame elements, i.e. <inline-formula><mml:math id="M40" altimg="si66.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mo>˚</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> for all <italic>l</italic>.</p>
      </sec>
      <sec id="s000020">
        <label>2.2</label>
        <title>Gabor theory</title>
        <p>Recall that for any nonzero function <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic> ∈ <italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M41" altimg="si68.gif" display="inline" overflow="scroll"><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> (the <italic>window</italic>), the <italic>short-time Fourier transform</italic> (STFT) of a signal <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic> ∈ <italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M42" altimg="si69.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is defined as <inline-formula><alternatives><textual-form specific-use="jats-markup">𝒱<sub><italic>g</italic></sub>(<italic>f</italic>)(<italic>τ</italic>, <italic>ω</italic>) = 〈<italic>f</italic>, <italic>M</italic><sub><italic>ω</italic></sub><italic>T</italic><sub><italic>τ</italic></sub><italic>g</italic>〉</textual-form><mml:math id="M43" altimg="si70.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">V</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ω</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>τ</mml:mi></mml:mrow></mml:msub><mml:mi>g</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, using the <italic>translation operator</italic> <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>T</italic><sub><italic>τ</italic></sub><italic>f</italic>(<italic>t</italic>) = <italic>f</italic>(<italic>t</italic> − <italic>τ</italic>)</textual-form><mml:math id="M44" altimg="si71.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>τ</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and the <italic>modulation operator</italic> <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>M</italic><sub><italic>ω</italic></sub><italic>f</italic>(<italic>t</italic>) = <italic>f</italic>(<italic>t</italic>)<italic>e</italic><sup>2<italic>π</italic><italic>i</italic><italic>ω</italic><italic>t</italic></sup></textual-form><mml:math id="M45" altimg="si72.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>ω</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>. In <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M46" altimg="si73.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, we have <disp-formula id="fd000015"><mml:math id="M47" altimg="si74.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">V</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ω</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>ω</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mtext>.</mml:mtext></mml:math></disp-formula></p>
        <p>For a non-zero window function <italic>g</italic> and parameters <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>a</italic>, <italic>b</italic> &gt; 0</textual-form><mml:math id="M48" altimg="si76.gif" display="inline" overflow="scroll"><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></alternatives></inline-formula>, the set of time–frequency shifts of <italic>g</italic><disp-formula id="fd000020"><alternatives><textual-form specific-use="jats-markup">𝒢(<italic>g</italic>, <italic>a</italic>, <italic>b</italic>) = {<italic>M</italic><sub><italic>b</italic><italic>m</italic></sub><italic>T</italic><sub><italic>a</italic><italic>n</italic></sub><italic>g</italic>:<italic>m</italic>, <italic>n</italic> ∈ ℤ}</textual-form><mml:math id="M49" altimg="si78.gif" display="block" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>g</mml:mi><mml:mo>:</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></disp-formula> is called a <italic>Gabor system</italic> <xref rid="br000095" ref-type="bibr">[19]</xref>. Moreover, if <inline-formula><alternatives><textual-form specific-use="jats-markup">𝒢(<italic>g</italic>, <italic>a</italic>, <italic>b</italic>)</textual-form><mml:math id="M50" altimg="si79.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is a frame, it is called a <italic>Gabor frame</italic> and the associated frame operator is denoted by <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>S</italic><sub><italic>g</italic>, <italic>a</italic>, <italic>b</italic></sub></textual-form><mml:math id="M51" altimg="si80.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. In the succeeding sections, where the dependence of the frame operator on the window <italic>g</italic> and the parameters <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>a</italic>, <italic>b</italic></textual-form><mml:math id="M52" altimg="si82.gif" display="inline" overflow="scroll"><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:math></alternatives></inline-formula> is clear, we simply denote the frame operator by <italic>S</italic>. Note that the Gabor analysis coefficients are sampling points of the STFT of <italic>f</italic> with window <italic>g</italic> at the time–frequency points <inline-formula><alternatives><textual-form specific-use="jats-markup">(<italic>a</italic><italic>n</italic>, <italic>b</italic><italic>m</italic>)</textual-form><mml:math id="M53" altimg="si86.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mi>m</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, i.e. <inline-formula><alternatives><textual-form specific-use="jats-markup">𝒱<sub><italic>g</italic></sub>(<italic>f</italic>)(<italic>a</italic><italic>n</italic>, <italic>b</italic><italic>m</italic>) = {〈<italic>f</italic>, <italic>M</italic><sub><italic>b</italic><italic>m</italic></sub><italic>T</italic><sub><italic>a</italic><italic>n</italic></sub><italic>g</italic>〉}<sub><italic>m</italic>, <italic>n</italic></sub></textual-form><mml:math id="M54" altimg="si87.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">V</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mi>m</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>g</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>.</p>
        <p>A central property of Gabor frames is the fact that the dual frame of a Gabor frame is again a Gabor frame, generated by the <italic>dual window</italic> <inline-formula><mml:math id="M55" altimg="si88.gif" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>˜</mml:mo></mml:mrow></mml:mover><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>g</mml:mi></mml:math></inline-formula> and the same <italic>lattice</italic>, i.e. the set of time–frequency points <inline-formula><alternatives><textual-form specific-use="jats-markup">{(<italic>a</italic><italic>n</italic>, <italic>b</italic><italic>m</italic>)|<italic>m</italic>, <italic>n</italic> ∈ ℤ}</textual-form><mml:math id="M56" altimg="si89.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mi>m</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Note that the property that the dual system is again a system with the same structure, is a particular property of Gabor frames, shared by nonstationary Gabor frames in the painless setting considered in the present paper. For a more detailed introduction to Gabor analysis, see <xref rid="br000005" ref-type="bibr">[1]</xref> or <xref rid="br000100" ref-type="bibr">[20]</xref>.</p>
        <p>In the finite discrete case, we take the Hilbert space ℋ to be <inline-formula><alternatives><textual-form specific-use="jats-markup">ℂ<sup><italic>L</italic></sup></textual-form><mml:math id="M57" altimg="si91.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>. For a good introduction to Gabor analysis in this setting, see <xref rid="br000105" ref-type="bibr">[21]</xref>. We shall restrict the lattice parameters <italic>a</italic> and <italic>b</italic> to factors of <italic>L</italic> such that the numbers <inline-formula><mml:math id="M58" altimg="si95.gif" display="inline" overflow="scroll"><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mfrac></mml:math></inline-formula> and <inline-formula><mml:math id="M59" altimg="si96.gif" display="inline" overflow="scroll"><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:math></inline-formula> are integers. We regard all vectors as periodic, so discrete translation is a cyclic operator. Therefore, the discretization of time-shift and modulation is given by <disp-formula id="fd000025"><alternatives><textual-form specific-use="jats-markup"><italic>T</italic><sub><italic>n</italic></sub><italic>x</italic> = (<italic>x</italic><sub><italic>L</italic> − <italic>n</italic></sub>, <italic>x</italic><sub><italic>L</italic> − <italic>n</italic> + 1</sub>, …, <italic>x</italic><sub>0</sub>, <italic>x</italic><sub>1</sub>, …, <italic>x</italic><sub><italic>L</italic> − <italic>n</italic> − 1</sub>)</textual-form><mml:math id="M60" altimg="si97.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></disp-formula> and <disp-formula id="fd000030"><mml:math id="M61" altimg="si98.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>⋅</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:mrow></mml:math></disp-formula> with <inline-formula><mml:math id="M62" altimg="si99.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:math></inline-formula>, respectively. We will consider the Gabor system <disp-formula id="fd000035"><alternatives><textual-form specific-use="jats-markup">𝒢(<italic>g</italic>, <italic>a</italic>, <italic>b</italic>) = {<italic>M</italic><sub><italic>b</italic><italic>m</italic></sub><italic>T</italic><sub><italic>a</italic><italic>n</italic></sub><italic>g</italic>:<italic>n</italic> = 0, …, <italic>N</italic> − 1; <italic>m</italic> = 0, …, <italic>M</italic> − 1},</textual-form><mml:math id="M63" altimg="si100.gif" display="block" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>g</mml:mi><mml:mo>:</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>;</mml:mo><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mtext>,</mml:mtext></mml:math></alternatives></disp-formula> which is a collection of <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>M</italic> ⋅ <italic>N</italic></textual-form><mml:math id="M64" altimg="si101.gif" display="inline" overflow="scroll"><mml:mi>M</mml:mi><mml:mo>⋅</mml:mo><mml:mi>N</mml:mi></mml:math></alternatives></inline-formula> vectors in <inline-formula><alternatives><textual-form specific-use="jats-markup">ℂ<sup><italic>L</italic></sup></textual-form><mml:math id="M65" altimg="si102.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>. Obviously, to fulfill the frame conditions <xref rid="fd000005" ref-type="disp-formula">(1)</xref>, we need at least <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>M</italic> ⋅ <italic>N</italic> ≥ <italic>L</italic></textual-form><mml:math id="M66" altimg="si103.gif" display="inline" overflow="scroll"><mml:mi>M</mml:mi><mml:mo>⋅</mml:mo><mml:mi>N</mml:mi><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:math></alternatives></inline-formula>.</p>
      </sec>
      <sec id="s000025">
        <label>2.3</label>
        <title>Wavelet theory</title>
        <p>As we will see below, nonstationary Gabor frames may be used to construct wavelet frames. We briefly sketch the continuous wavelet transform. Let <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ψ</italic> ∈ <italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M67" altimg="si104.gif" display="inline" overflow="scroll"><mml:mi>ψ</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula><mml:math id="M68" altimg="si105.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>(</mml:mo><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>×</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:math></inline-formula>. We define the wavelet system by <disp-formula id="fd000040"><label>(2)</label><mml:math id="M69" altimg="si106.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:mi>ψ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>β</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mi>ψ</mml:mi><mml:mtext>,</mml:mtext></mml:math></disp-formula> where <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>D</italic><sub><italic>α</italic></sub></textual-form><mml:math id="M70" altimg="si107.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> denotes the dilation operator given by <inline-formula><mml:math id="M71" altimg="si108.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>The wavelet transform is then defined as <disp-formula id="fd000045"><label>(3)</label><mml:math id="M72" altimg="si109.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>W</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>β</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>∗</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mover accent="false"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mi>ψ</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>β</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>,</mml:mtext></mml:math></disp-formula> where ℐ denotes the involution <inline-formula><alternatives><textual-form specific-use="jats-markup">ℐ<italic>g</italic>(<italic>t</italic>) = <italic>g</italic>( − <italic>t</italic>)</textual-form><mml:math id="M73" altimg="si111.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        <p>If <italic>ψ</italic> is localized around <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>τ</italic><sub>0</sub></textual-form><mml:math id="M74" altimg="si113.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, then <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ψ</italic><sub><italic>α</italic>, <italic>β</italic></sub>(<italic>t</italic>)</textual-form><mml:math id="M75" altimg="si114.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is centered at <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>α</italic> ⋅ <italic>τ</italic><sub>0</sub> + <italic>β</italic></textual-form><mml:math id="M76" altimg="si115.gif" display="inline" overflow="scroll"><mml:mi>α</mml:mi><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>β</mml:mi></mml:math></alternatives></inline-formula>. The frequency center is at <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>η</italic> / <italic>α</italic></textual-form><mml:math id="M77" altimg="si116.gif" display="inline" overflow="scroll"><mml:mi>η</mml:mi><mml:mo>/</mml:mo><mml:mi>α</mml:mi></mml:math></alternatives></inline-formula>, where <italic>η</italic> is the center of <inline-formula><mml:math id="M78" altimg="si118.gif" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:math></inline-formula>.</p>
      </sec>
    </sec>
    <sec id="s000030">
      <label>3</label>
      <title>Construction of nonstationary Gabor frames</title>
      <sec id="s000035">
        <label>3.1</label>
        <title>Resolution changing over time</title>
        <p>As opposed to standard Gabor analysis, where time translation is used to generate atoms, the setting of nonstationary Gabor frames allows for changing, hence adaptive, windows in different time positions. Then, for each time position, we build atoms by <italic>regular</italic> frequency modulation. Using a set of functions <inline-formula><alternatives><textual-form specific-use="jats-markup">{<italic>g</italic><sub><italic>n</italic></sub>}<sub><italic>n</italic> ∈ ℤ</sub></textual-form><mml:math id="M79" altimg="si119.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> in <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M80" altimg="si120.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and frequency sampling step <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>b</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M81" altimg="si121.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, for <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>m</italic> ∈ ℤ</textual-form><mml:math id="M82" altimg="si122.gif" display="inline" overflow="scroll"><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>n</italic> ∈ ℤ</textual-form><mml:math id="M83" altimg="si123.gif" display="inline" overflow="scroll"><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:math></alternatives></inline-formula>, we define atoms of the form: <disp-formula id="fd000050"><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>m</italic>, <italic>n</italic></sub>(<italic>t</italic>) = <italic>g</italic><sub><italic>n</italic></sub>(<italic>t</italic>)<italic>e</italic><sup>2<italic>π</italic><italic>i</italic><italic>m</italic><italic>b</italic><sub><italic>n</italic></sub><italic>t</italic></sup> = <italic>M</italic><sub><italic>m</italic><italic>b</italic><sub><italic>n</italic></sub></sub><italic>g</italic><sub><italic>n</italic></sub>(<italic>t</italic>),</textual-form><mml:math id="M84" altimg="si124.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>,</mml:mtext></mml:math></alternatives></disp-formula> implicitly assuming that the functions <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M85" altimg="si125.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> are well-localized and centered around time-points <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>a</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M86" altimg="si126.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. This is similar to the standard Gabor scheme, however, with the possibility to vary the window <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M87" altimg="si127.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> for each position <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>a</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M88" altimg="si128.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. Thus, sampling of the time–frequency plane is done on a grid which is irregular over time, but regular over frequency at each temporal position.</p>
        <p><xref rid="f000005" ref-type="fig">Fig. 1</xref> shows an example of such a sampling grid. Note that some results exist in Gabor theory for semi-regular sampling grids, as for example in <xref rid="br000110" ref-type="bibr">[22]</xref>. Our study uses a more general setting, as the sampling grid is in general not separable and, more importantly, the window can evolve over time. To get a first idea of the effect of nonstationary Gabor frames, the reader may take a look at <xref rid="f000010 f000015" ref-type="fig">Figs. 2 and 3</xref>, which show regular Gabor transforms and a nonstationary Gabor transform of the same signal. Note that the NSGT in <xref rid="f000015" ref-type="fig">Fig. 3</xref> was adapted to transients and the components are well-resolved.</p>
        <p>In the current situation, the analysis coefficients may be written as <disp-formula id="fd000055"><mml:math id="M89" altimg="si129.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>⋅</mml:mo><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mtext>,</mml:mtext><mml:mspace width="1em" class="quad"/><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi><mml:mtext>.</mml:mtext></mml:math></disp-formula></p>
        <p>
          <statement id="e000005">
            <label>Remark 1</label>
            <p>If we set <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub>(<italic>t</italic>) = <italic>g</italic>(<italic>t</italic> − <italic>n</italic><italic>a</italic>)</textual-form><mml:math id="M90" altimg="si130.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> for a fixed time-constant <italic>a</italic> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>b</italic><sub><italic>n</italic></sub> = <italic>b</italic></textual-form><mml:math id="M91" altimg="si132.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:math></alternatives></inline-formula> for all <italic>n</italic>, we obtain the case of classical painless non-orthogonal expansions for regular Gabor systems introduced in <xref rid="br000050" ref-type="bibr">[10]</xref>.</p>
          </statement>
        </p>
      </sec>
      <sec id="s000040">
        <label>3.2</label>
        <title>Resolution changing over frequency</title>
        <p>An analog construction in the frequency domain leads to irregular sampling over frequency, together with windows featuring adaptive bandwidth. Then, sampling is regular over time. An example of the sampling grid in such a case is given in <xref rid="f000020" ref-type="fig">Fig. 4</xref>.</p>
        <p>In this case, we introduce a family of functions <inline-formula><alternatives><textual-form specific-use="jats-markup">{<italic>h</italic><sub><italic>m</italic></sub>}<sub><italic>m</italic> ∈ ℤ</sub></textual-form><mml:math id="M92" altimg="si134.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> of <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M93" altimg="si135.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, and for <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>m</italic> ∈ ℤ</textual-form><mml:math id="M94" altimg="si136.gif" display="inline" overflow="scroll"><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>n</italic> ∈ ℤ</textual-form><mml:math id="M95" altimg="si137.gif" display="inline" overflow="scroll"><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:math></alternatives></inline-formula>, we define atoms of the form: <disp-formula id="fd000060"><label>(4)</label><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic>, <italic>n</italic></sub>(<italic>t</italic>) = <italic>h</italic><sub><italic>m</italic></sub>(<italic>t</italic> − <italic>n</italic><italic>a</italic><sub><italic>m</italic></sub>).</textual-form><mml:math id="M96" altimg="si138.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mtext>.</mml:mtext></mml:math></alternatives></disp-formula> Therefore <inline-formula><mml:math id="M97" altimg="si139.gif" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mi>ν</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> and the analysis coefficients may be written as <disp-formula id="fd000065"><mml:math id="M98" altimg="si140.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mi mathvariant="script">F</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover><mml:mo>⋅</mml:mo><mml:mover accent="false"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mtext>.</mml:mtext></mml:math></disp-formula> Hence, the situation is completely analog to the one described in the previous section, up to a Fourier transform.</p>
        <p>In practice we will choose each function <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic></sub></textual-form><mml:math id="M99" altimg="si141.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> as a well localized band-pass function with center frequency <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>b</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M100" altimg="si142.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>.</p>
        <sec id="s000045">
          <label>3.2.1</label>
          <title>Link between nonstationary Gabor frames, wavelet frames and filter banks</title>
          <p>To obtain wavelet frames, the wavelet transform in <xref rid="fd000040" ref-type="disp-formula">(2)</xref> is sampled at sampling points <inline-formula><alternatives><textual-form specific-use="jats-markup">(<italic>β</italic><sub><italic>n</italic></sub>, <italic>α</italic><sub><italic>m</italic></sub>)</textual-form><mml:math id="M101" altimg="si143.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. A typical discretization scheme <xref rid="br000115" ref-type="bibr">[23]</xref> is <inline-formula><mml:math id="M102" altimg="si144.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>. Then, the frame elements are <inline-formula><mml:math id="M103" altimg="si145.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mi>ψ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>. Comparing this expression to <xref rid="fd000060" ref-type="disp-formula">(4)</xref> and setting <inline-formula><mml:math id="M104" altimg="si146.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mi>ψ</mml:mi></mml:math></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>a</italic><sub><italic>m</italic></sub> = <italic>β</italic><sub>0</sub></textual-form><mml:math id="M105" altimg="si147.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, we see that a wavelet frame with this discretization scheme corresponds to a nonstationary Gabor transform.</p>
          <p>Another possibility for sampling the continuous wavelet transform <xref rid="br000010" ref-type="bibr">[2]</xref> uses <inline-formula><mml:math id="M106" altimg="si148.gif" display="inline" overflow="scroll"><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> and <inline-formula><mml:math id="M107" altimg="si149.gif" display="inline" overflow="scroll"><mml:mi>β</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula>. Again, we obtain a correspondence to nonstationary Gabor frames by setting <inline-formula><mml:math id="M108" altimg="si150.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mi>ψ</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M109" altimg="si151.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msubsup><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula>.</p>
          <p>Beyond the setting of wavelets, any <italic>filter bank</italic> <xref rid="br000115" ref-type="bibr">[23]</xref>, even with non-constant down-sampling factors <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>D</italic><sub><italic>m</italic></sub></textual-form><mml:math id="M110" altimg="si152.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, can be written as a nonstationary Gabor frame. A filter bank is a set of time-invariant, linear filters <inline-formula><alternatives><textual-form specific-use="jats-markup">𝔥<sub><italic>m</italic></sub></textual-form><mml:math id="M111" altimg="si153.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="fraktur">h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, i.e. Fourier multipliers. The response of a filter bank for the signal <italic>f</italic> and sampling period <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>T</italic><sub>0</sub></textual-form><mml:math id="M112" altimg="si155.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> is given (in the continuous case) by <disp-formula id="fd000070"><alternatives><textual-form specific-use="jats-markup"><italic>c</italic><sub><italic>m</italic>, <italic>n</italic></sub> = (<italic>f</italic> ∗ 𝔥<sub><italic>m</italic></sub>)(<italic>n</italic><italic>D</italic><sub><italic>m</italic></sub><italic>T</italic><sub>0</sub>) = ∫<sub>ℝ</sub><italic>f</italic>(<italic>t</italic>)𝔥<sub><italic>m</italic></sub>(<italic>n</italic><italic>D</italic><sub><italic>m</italic></sub><italic>T</italic><sub>0</sub> − <italic>t</italic>)<italic>d</italic><italic>t</italic> = 〈<italic>f</italic>, <italic>h</italic><sub><italic>m</italic>, <italic>n</italic></sub>〉,</textual-form><mml:math id="M113" altimg="si156.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>∗</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="fraktur">h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="fraktur">h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow><mml:mtext>,</mml:mtext></mml:math></alternatives></disp-formula> where <inline-formula><mml:math id="M114" altimg="si157.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="false"><mml:mrow><mml:mi mathvariant="fraktur">h</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math></inline-formula>. Setting <inline-formula><mml:math id="M115" altimg="si158.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mover accent="false"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="fraktur">h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math></inline-formula> and choosing <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>a</italic><sub><italic>m</italic></sub> = <italic>D</italic><sub><italic>m</italic></sub><italic>T</italic><sub>0</sub></textual-form><mml:math id="M116" altimg="si159.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> this construction is realized with nonstationary Gabor frames using <xref rid="fd000060" ref-type="disp-formula">(4)</xref>. If the filters are band-limited and the down-sampling factors are small enough, then the conditions for the painless case are met and the corresponding reconstruction procedure can be applied.</p>
        </sec>
      </sec>
      <sec id="s000050">
        <label>3.3</label>
        <title>Invertibility of the frame operator and reconstruction</title>
        <p>In this central section, we give the precise conditions under which painless nonstationary Gabor frames are constructed. The first two basic conditions, namely compactly supported windows and sufficiently dense frequency sampling points, lead to diagonality of the associated frame operator <italic>S</italic>, as defined in Section <xref rid="s000015" ref-type="sec">2.1</xref>. The third condition, the controlled overlap of adjacent windows, then leads to boundedness and invertibility of <italic>S</italic>. The following theorem generalizes the results given for the classical case of painless non-orthogonal expansions <xref rid="br000050 br000100" ref-type="bibr">[10,20]</xref>. <statement id="e000010"><label>Theorem 1</label><p><italic>For every</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>n</italic> ∈ ℤ</textual-form><mml:math id="M117" altimg="si162.gif" display="inline" overflow="scroll"><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:math></alternatives></inline-formula><italic>, let the function</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub> ∈ <italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M118" altimg="si163.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula><italic>be compactly supported with</italic><inline-formula><alternatives><textual-form specific-use="jats-markup">supp(<italic>g</italic><sub><italic>n</italic></sub>) ⊆ [<italic>c</italic><sub><italic>n</italic></sub>, <italic>d</italic><sub><italic>n</italic></sub>]</textual-form><mml:math id="M119" altimg="si164.gif" display="inline" overflow="scroll"><mml:mo>supp</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>⊆</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo></mml:mrow></mml:math></alternatives></inline-formula><italic>and let</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>b</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M120" altimg="si165.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula><italic>be chosen such that</italic><inline-formula><mml:math id="M121" altimg="si166.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math></inline-formula><italic>. Then the frame operator</italic><disp-formula id="fd000075"><mml:math id="M122" altimg="si167.gif" display="block" overflow="scroll"><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mo>:</mml:mo><mml:mi>f</mml:mi><mml:mo>↦</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></disp-formula><italic>of the system</italic><disp-formula id="fd000080"><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>m</italic>, <italic>n</italic></sub>(<italic>t</italic>) = <italic>g</italic><sub><italic>n</italic></sub>(<italic>t</italic>)<italic>e</italic><sup>2<italic>π</italic><italic>i</italic><italic>m</italic><italic>b</italic><sub><italic>n</italic></sub><italic>t</italic></sup>, <italic>m</italic> ∈ ℤ and <italic>n</italic> ∈ ℤ,</textual-form><mml:math id="M123" altimg="si168.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mtext>,</mml:mtext><mml:mspace width="1em" class="quad"/><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi><mml:mspace class="nbsp"/><mml:mtext>and</mml:mtext><mml:mspace class="nbsp"/><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi><mml:mtext>,</mml:mtext></mml:math></alternatives></disp-formula><italic>is given by a multiplication operator of the form</italic><disp-formula id="fd000085"><mml:math id="M124" altimg="si169.gif" display="block" overflow="scroll"><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>.</mml:mtext></mml:math></disp-formula></p></statement></p>
        <p>
          <statement id="e000015">
            <label>Proof</label>
            <p>Note that, <disp-formula id="fd000090"><mml:math id="M125" altimg="si170.gif" display="block" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mtext>,</mml:mtext></mml:math></disp-formula> due to the compact support property of the windows <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M126" altimg="si171.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. Let <inline-formula><mml:math id="M127" altimg="si172.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula> for all <italic>n</italic> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>χ</italic><sub><italic>I</italic></sub></textual-form><mml:math id="M128" altimg="si174.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> denote the characteristic function of the interval <italic>I</italic>. Taking into account the compact support of <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M129" altimg="si176.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> again, it is obvious that <disp-formula id="fd000095"><mml:math id="M130" altimg="si177.gif" display="block" overflow="scroll"><mml:mi>f</mml:mi><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:munderover accentunder="false" accent="false"><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>)</mml:mo></mml:mrow><mml:mtext>,</mml:mtext></mml:math></disp-formula> with the <inline-formula><mml:math id="M131" altimg="si178.gif" display="inline" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula>-periodic function <inline-formula><mml:math id="M132" altimg="si179.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:msubsup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>. Hence, with <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>W</italic><sub><italic>m</italic>, <italic>n</italic></sub>(<italic>t</italic>) = <italic>e</italic><sup> − 2<italic>π</italic><italic>i</italic><italic>m</italic><italic>b</italic><sub><italic>n</italic></sub><italic>t</italic></sup></textual-form><mml:math id="M133" altimg="si180.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>, <disp-formula id="fd000100"><mml:math id="M134" altimg="si181.gif" display="block" overflow="scroll"><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></disp-formula> and applying Parseval’s identity to the sum over <italic>m</italic> yields <disp-formula id="fd000105"><mml:math id="M135" altimg="si183.gif" display="block" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>f</mml:mi><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>f</mml:mi><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mtext>.</mml:mtext></mml:math></disp-formula> □</p>
          </statement>
        </p>
        <p>While in general, the inversion of <italic>S</italic> can be numerically unfeasible, in the special case described in <xref rid="e000010" ref-type="statement">Theorem 1</xref>, the invertibility of the frame operator is easy to check and inversion is a simple multiplication. <statement id="e000020"><label>Corollary 1</label><p><italic>Under the conditions given in</italic> <xref rid="e000010" ref-type="statement">Theorem 1</xref><italic>, the system of functions</italic> <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>m</italic>, <italic>n</italic></sub></textual-form><mml:math id="M136" altimg="si185.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> <italic>forms a frame for</italic> <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M137" altimg="si186.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> <italic>if and only if</italic> <inline-formula><mml:math id="M138" altimg="si187.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≃</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> <italic>. In this case, the canonical dual frame elements are given by</italic><disp-formula id="fd000110"><label>(5)</label><mml:math id="M139" altimg="si188.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>˜</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mtext>,</mml:mtext></mml:math></disp-formula><italic>and the associated canonical tight frame elements can be calculated as:</italic><disp-formula id="fd000115"><mml:math id="M140" altimg="si189.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>˚</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mtext>.</mml:mtext></mml:math></disp-formula></p></statement></p>
        <p>
          <statement id="e000025">
            <label>Remark 2</label>
            <p>The optimal lower and upper frame bounds are explicitly given by <inline-formula><mml:math id="M141" altimg="si190.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>opt</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>essinf</mml:mo><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> and <inline-formula><mml:math id="M142" altimg="si191.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>opt</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>esssup</mml:mo><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula>.</p>
          </statement>
        </p>
        <p>We next state the results of <xref rid="e000010" ref-type="statement">Theorem 1</xref> and <xref rid="e000020" ref-type="statement">Corollary 1</xref> in the Fourier domain. This is the basis for adaptation over frequency. <statement id="e000030"><label>Corollary 2</label><p><italic>For every</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>m</italic> ∈ ℤ</textual-form><mml:math id="M143" altimg="si192.gif" display="inline" overflow="scroll"><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:math></alternatives></inline-formula><italic>, let the function</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic></sub></textual-form><mml:math id="M144" altimg="si193.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula><italic>be band-limited to</italic><inline-formula><mml:math id="M145" altimg="si194.gif" display="inline" overflow="scroll"><mml:mo>supp</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula><italic>and let</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>a</italic><sub><italic>m</italic></sub></textual-form><mml:math id="M146" altimg="si195.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula><italic>be chosen such that</italic><inline-formula><mml:math id="M147" altimg="si196.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math></inline-formula><italic>. Then the frame operator of the system</italic><disp-formula id="fd000120"><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic>, <italic>n</italic></sub>(<italic>t</italic>) = <italic>h</italic><sub><italic>m</italic></sub>(<italic>t</italic> − <italic>n</italic><italic>a</italic><sub><italic>m</italic></sub>), <italic>m</italic> ∈ ℤ,  <italic>n</italic> ∈ ℤ</textual-form><mml:math id="M148" altimg="si197.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mtext>,</mml:mtext><mml:mspace width="1em" class="quad"/><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi><mml:mo>,</mml:mo><mml:mspace class="nbsp"/><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:math></alternatives></disp-formula><italic>is given by a convolution operator of the form</italic><disp-formula id="fd000125"><label>(6)</label><mml:math id="M149" altimg="si198.gif" display="block" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>∗</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></disp-formula><italic>for</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic> ∈ <italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M150" altimg="si199.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula><italic>. Hence, the system of functions</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic>, <italic>n</italic></sub></textual-form><mml:math id="M151" altimg="si200.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula><italic>forms a frame of</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sup>2</sup>(ℝ)</textual-form><mml:math id="M152" altimg="si201.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula><italic>if and only if</italic><inline-formula><mml:math id="M153" altimg="si202.gif" display="inline" overflow="scroll"><mml:mi>∀</mml:mi><mml:mi>ν</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≃</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula><italic>. The elements of the canonical dual frame are given by</italic><disp-formula id="fd000130"><label>(7)</label><mml:math id="M154" altimg="si203.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo>˜</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></disp-formula><italic>and the canonical tight frame is given by</italic><disp-formula id="fd000135"><label>(8)</label><mml:math id="M155" altimg="si204.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo>˚</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>.</mml:mtext></mml:math></disp-formula></p></statement></p>
        <p>
          <statement id="e000035">
            <label>Proof</label>
            <p>We deduce the form of the frame operator in the current setting from the proof of <xref rid="e000010" ref-type="statement">Theorem 1</xref> by setting <disp-formula id="fd000140"><mml:math id="M156" altimg="si205.gif" display="block" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mover accent="true"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>〉</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></disp-formula> and the rest of the corollary is equivalent to <xref rid="e000020" ref-type="statement">Corollary 1</xref>. □</p>
          </statement>
        </p>
        <p>
          <statement id="e000040">
            <label>Remark 3</label>
            <p>Classical Gabor frames are intimately related to modulation spaces, see <xref rid="br000120" ref-type="bibr">[24]</xref> for an extensive discussion and relevant references. The characterization of modulation spaces depends on the joint time–frequency localization of the analysis window. Painless nonstationary Gabor frames characterize modulation spaces, if, in addition to compactness in one domain (time or frequency), the windows <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>k</italic></sub></textual-form><mml:math id="M157" altimg="si206.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> exhibit a uniform decay in the sense of <italic>time</italic>–<italic>frequency molecules</italic>, see <xref rid="br000125" ref-type="bibr">[25, Theorem 22]</xref>, i.e., letting <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ξ</italic> = (<italic>a</italic><sub><italic>k</italic></sub>, <italic>l</italic> / <italic>b</italic><sub><italic>k</italic></sub>), <italic>k</italic>, <italic>l</italic> ∈ ℤ</textual-form><mml:math id="M158" altimg="si207.gif" display="inline" overflow="scroll"><mml:mi>ξ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:math></alternatives></inline-formula>, we require <inline-formula><alternatives><textual-form specific-use="jats-markup">|𝒱<sub><italic>φ</italic></sub><italic>g</italic><sub><italic>k</italic></sub>(<italic>z</italic>)| ≤ <italic>C</italic>(1 + |<italic>z</italic> − <italic>ξ</italic>|)<sup> − <italic>r</italic></sup></textual-form><mml:math id="M159" altimg="si208.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">V</mml:mi></mml:mrow><mml:mrow><mml:mi>φ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>z</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>C</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>z</mml:mi><mml:mo>−</mml:mo><mml:mi>ξ</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula> for some <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>r</italic> &gt; 2</textual-form><mml:math id="M160" altimg="si209.gif" display="inline" overflow="scroll"><mml:mi>r</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>2</mml:mn></mml:math></alternatives></inline-formula>. Then, the corresponding frame operator is invertible on all modulation spaces <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>M</italic><sup><italic>p</italic></sup>, 1 ≤ <italic>p</italic> ≤ <italic>∞</italic></textual-form><mml:math id="M161" altimg="si210.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo>≤</mml:mo><mml:mi>∞</mml:mi></mml:math></alternatives></inline-formula>, and the <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ℓ</italic><sup><italic>p</italic></sup></textual-form><mml:math id="M162" altimg="si211.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>-norm of the corresponding coefficient sequence is equivalent to the modulation space norm.</p>
          </statement>
        </p>
        <p>
          <statement id="e000045">
            <label>Remark 4</label>
            <p>As mentioned in Section <xref rid="s000045" ref-type="sec">3.2.1</xref> the NSGT is linked to wavelet frames. In the painless case it is possible to construct a dual sequence which has the same structure. For wavelets this is also possible, see e.g. <xref rid="br000130 br000135" ref-type="bibr">[26,27]</xref>, where non-canonical duals are constructed.</p>
            <p>In a similar way as modulation spaces are linked to the Gabor transform, Besov spaces are related to wavelet systems; see e.g. <xref rid="br000140" ref-type="bibr">[28]</xref>. Also, Sobolev spaces can be linked to the wavelet transform <xref rid="br000145" ref-type="bibr">[29]</xref>. Nonstationary Gabor frames can also be used to characterize Besov and Sobolev spaces, with some additional assumptions. Details will be reported elsewhere.</p>
          </statement>
        </p>
      </sec>
    </sec>
    <sec id="s000055">
      <label>4</label>
      <title>Discrete finite nonstationary Gabor frames</title>
      <sec id="s000060">
        <label>4.1</label>
        <title>Discrete, time-adaptive Gabor transform</title>
        <p>For the practical implementation, the equivalent theory may be developed in a finite discrete setting using the Hilbert space <inline-formula><alternatives><textual-form specific-use="jats-markup">ℂ<sup><italic>L</italic></sup></textual-form><mml:math id="M163" altimg="si212.gif" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>. Since this is largely straight-forward from simple matrix multiplication, we only state the main result. Given a set of functions <inline-formula><alternatives><textual-form specific-use="jats-markup">{<italic>g</italic><sub><italic>n</italic></sub>}<sub><italic>n</italic> ∈ {0, …, <italic>N</italic> − 1}</sub></textual-form><mml:math id="M164" altimg="si213.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, a set of integers (number of frequency samples for each time position) <inline-formula><alternatives><textual-form specific-use="jats-markup">{<italic>M</italic><sub><italic>n</italic></sub>}<sub><italic>n</italic> ∈ {0, …, <italic>N</italic> − 1}</sub></textual-form><mml:math id="M165" altimg="si214.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> associated with the set of real values <inline-formula><mml:math id="M166" altimg="si215.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math></inline-formula>, the discrete, nonstationary Gabor system is given by <disp-formula id="fd000145"><mml:math id="M167" altimg="si216.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:math></disp-formula> for <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>n</italic> = 0, …, <italic>N</italic> − 1, <italic>m</italic> = 0, …, <italic>M</italic><sub><italic>n</italic></sub> − 1</textual-form><mml:math id="M168" altimg="si217.gif" display="inline" overflow="scroll"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:math></alternatives></inline-formula> and all <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>k</italic> = 0, …, <italic>L</italic> − 1</textual-form><mml:math id="M169" altimg="si218.gif" display="inline" overflow="scroll"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:math></alternatives></inline-formula>. Note that in practice, <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>m</italic>, <italic>n</italic></sub>[<italic>k</italic>]</textual-form><mml:math id="M170" altimg="si219.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> will have zero-values for most <italic>k</italic>, allowing for efficient FFT-implementation: since <inline-formula><mml:math id="M171" altimg="si221.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math></inline-formula>, we have <inline-formula><mml:math id="M172" altimg="si222.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:math></inline-formula> and the nonstationary Gabor coefficients are given by an FFT of length <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>M</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M173" altimg="si223.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> for each <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M174" altimg="si224.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>.</p>
        <p>The number of elements of <inline-formula><alternatives><textual-form specific-use="jats-markup">{<italic>g</italic><sub><italic>m</italic>, <italic>n</italic></sub>}</textual-form><mml:math id="M175" altimg="si225.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is <inline-formula><mml:math id="M176" altimg="si226.gif" display="inline" overflow="scroll"><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. Let <italic>G</italic> be the <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic>×<italic>P</italic></textual-form><mml:math id="M177" altimg="si228.gif" display="inline" overflow="scroll"><mml:mi>L</mml:mi><mml:mo>×</mml:mo><mml:mi>P</mml:mi></mml:math></alternatives></inline-formula> matrix such that its <italic>p</italic>-th column is <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>m</italic>, <italic>n</italic></sub></textual-form><mml:math id="M178" altimg="si230.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, for <inline-formula><mml:math id="M179" altimg="si231.gif" display="inline" overflow="scroll"><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. <statement id="e000050"><label>Corollary 3</label><p><italic>The frame operator</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>S</italic> = <italic>G</italic> ⋅ <italic>G</italic><sup> ∗ </sup></textual-form><mml:math id="M180" altimg="si232.gif" display="inline" overflow="scroll"><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold"><mml:mi>G</mml:mi></mml:mstyle><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>G</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup></mml:math></alternatives></inline-formula><italic>is an</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic>×<italic>L</italic></textual-form><mml:math id="M181" altimg="si233.gif" display="inline" overflow="scroll"><mml:mi>L</mml:mi><mml:mo>×</mml:mo><mml:mi>L</mml:mi></mml:math></alternatives></inline-formula><italic>matrix with entries:</italic><disp-formula id="fd000150"><mml:math id="M182" altimg="si234.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>S</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mover accent="false"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math></disp-formula><italic>where</italic><inline-formula><alternatives><textual-form specific-use="jats-markup">𝒩<sub><italic>p</italic></sub> = {<italic>n</italic> ∈ [0, <italic>N</italic> − 1]|<italic>p</italic> = 0 mod <italic>M</italic><sub><italic>n</italic></sub>}</textual-form><mml:math id="M183" altimg="si235.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>|</mml:mo><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>mod</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula><italic>for</italic><inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>p</italic> ∈ [ − <italic>L</italic>, <italic>L</italic>]</textual-form><mml:math id="M184" altimg="si236.gif" display="inline" overflow="scroll"><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mo>−</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:math></alternatives></inline-formula><italic>. Therefore, if appropriate support conditions are met,</italic><italic>S</italic><italic>is a diagonal matrix.</italic></p></statement></p>
        <sec id="s000065">
          <label>4.1.1</label>
          <title>Numerical complexity</title>
          <p>Assuming that the windows <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M185" altimg="si238.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> have support of length <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M186" altimg="si239.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, let <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>M</italic> = max <sub><italic>n</italic></sub>{<italic>M</italic><sub><italic>n</italic></sub>}</textual-form><mml:math id="M187" altimg="si240.gif" display="inline" overflow="scroll"><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>max</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> be the maximum FFT-length. We consider the painless case where <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sub><italic>n</italic></sub> ≤ <italic>M</italic><sub><italic>n</italic></sub> ≤ <italic>M</italic></textual-form><mml:math id="M188" altimg="si241.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>M</mml:mi></mml:math></alternatives></inline-formula>. The number of operations is <list list-type="simple"><list-item><label>1.</label><p>Windowing: <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>L</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M189" altimg="si242.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> operations for the <italic>n</italic>-th window.</p></list-item><list-item><label>2.</label><p>FFT: <inline-formula><alternatives><textual-form specific-use="jats-markup">𝒪(<italic>M</italic><sub><italic>n</italic></sub> ⋅ log(<italic>M</italic><sub><italic>n</italic></sub>))</textual-form><mml:math id="M190" altimg="si244.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:mo>log</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> for the <italic>n</italic>-th window.</p></list-item></list></p>
          <p>Then the number of operations for the discrete NSGT is <disp-formula id="fd000155"><mml:math id="M191" altimg="si246.gif" display="block" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:munderover accentunder="false" accent="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:mo>log</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>N</mml:mi><mml:mo>⋅</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>M</mml:mi><mml:mo>log</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>M</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>M</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>N</mml:mi><mml:mo>⋅</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>M</mml:mi><mml:mo>log</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>M</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext>.</mml:mtext></mml:math></disp-formula> Similar to the regular Gabor case, the number of windows <italic>N</italic> will usually depend linearly on the signal length <italic>L</italic> while the maximum FFT-length <italic>M</italic> is assumed to be independent of <italic>L</italic>. In that case, the discrete NSGT is a linear cost algorithm.</p>
          <p>For the construction of the dual windows in the painless case, the computation involves multiplication of the window functions by the inverse of the diagonal matrix <italic>S</italic> and results in <inline-formula><mml:math id="M192" altimg="si252.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:msubsup><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>N</mml:mi><mml:mo>⋅</mml:mo><mml:mi>M</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> operations. Finally, the inverse NSGT has numerical complexity <inline-formula><alternatives><textual-form specific-use="jats-markup">𝒪(<italic>N</italic> ⋅ (<italic>M</italic>log(<italic>M</italic>)))</textual-form><mml:math id="M193" altimg="si253.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>N</mml:mi><mml:mo>⋅</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>M</mml:mi><mml:mo>log</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>M</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, as in the NSGT, since it entails computing the IFFT of each coefficient vector, multiplying with the corresponding dual windows and evaluating the sum.</p>
          <p><italic>Technical framework</italic>. All subsequently presented simulations were done in MATLAB R2009b on a 2 Gigahertz Intel Core 2 Duo machine with 2 Gigabytes of RAM running Kubuntu 9.04. The CQTs were computed using the code published with <xref rid="br000150" ref-type="bibr">[30]</xref>, available for free download at <ext-link ext-link-type="uri" xlink:href="http://www.elec.qmul.ac.uk/people/anssik/cqt/" id="ir000015">http://www.elec.qmul.ac.uk/people/anssik/cqt/</ext-link>. The constant-Q nonstationary Gabor transform (CQ-NSGT) algorithms are available at <ext-link ext-link-type="uri" xlink:href="http://univie.ac.at/nonstatgab/" id="ir000020">http://univie.ac.at/nonstatgab/</ext-link>.</p>
        </sec>
        <sec id="s000070">
          <label>4.1.2</label>
          <title>Application: automatic adaptation to transients</title>
          <p>In real-life applications, NSGT has the potential to represent local signal characteristics, e.g. transient sound events, in a more appropriate way than pre-determined, regular transform schemes. Since the appropriateness of a representation depends on the specific application, any adaptation procedure must be designed specifically. For the implementation itself, however, two observations generally remain true: first, the general nonstationary framework needs to be restricted to a well defined set of choices. Second, some measure is needed to determine the most suitable of the possible choices. For example, in the case of a sparsity measure, the most sparse representation will be chosen. To show that good results are achieved even when using quite simple adaptation methods, we describe a procedure suitable for signals consisting mainly of transient and sinusoidal components. The adaptation measure proposed is based on onset detection, i.e. estimating where transients occur in the signal. The transform setting is what we call <italic>scale frames</italic>: the analysis procedure uses a single window prototype and a countable set of dilations thereof.</p>
          <p>For evaluation, the representation quality is measured by comparison of the number of representation coefficients leading to certain root mean square (RMS) reconstruction errors, for both NSGT and regular Gabor transforms. The results are especially convincing for sparse music signals with high energy transient components. Other possible adaptation methods might be based on time–frequency concentration, sparsity or entropy measures <xref rid="br000045 br000155 br000160" ref-type="bibr">[9,31,32]</xref>.</p>
          <p><italic>Scale frames</italic>. In the following paragraphs, we propose a family of nonstationary Gabor frames that allows for exponential changes in time–frequency resolution along time positions. To avoid heavy notation and since the formalism necessary for the discrete, finite case could obscure the principal idea, we describe the continuous case construction. Suitable standard sampling then yields discrete, finite frames with equivalent characteristics.</p>
          <p>The basic idea is to build a sequence of windows <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M194" altimg="si254.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> from a single, continuous window prototype <italic>g</italic> with support on an interval of length 1 in such a way that the resulting <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M195" altimg="si256.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> satisfy <xref rid="e000020" ref-type="statement">Corollary 1</xref>. The window sequence will be unambiguously determined by a sequence of scales. Once this <italic>scale sequence</italic> is known, it is a simple task to choose modulation parameters <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>b</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M196" altimg="si257.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> satisfying the necessary conditions.</p>
          <p>As a scale sequence, we allow any integer-valued sequence <inline-formula><alternatives><textual-form specific-use="jats-markup">{<italic>s</italic><sub><italic>n</italic></sub>}<sub><italic>n</italic> ∈ ℤ</sub></textual-form><mml:math id="M197" altimg="si258.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> such that <inline-formula><alternatives><textual-form specific-use="jats-markup">|<italic>s</italic><sub><italic>n</italic></sub> − <italic>s</italic><sub><italic>n</italic> − 1</sub>| ∈ {0, 1}</textual-form><mml:math id="M198" altimg="si259.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, where the latter restriction is set in order to avoid sudden changes of window length. Then, <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M199" altimg="si260.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> is, up to translation, given by a dilation of the prototype <italic>g</italic>: <disp-formula id="fd000160"><mml:math id="M200" altimg="si262.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:msqrt><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>.</mml:mtext></mml:math></disp-formula> This implies that a change of scale from one time step to the next corresponds to the use of a window either half or twice as long. More precisely, for every time step <italic>n</italic>, set <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>s</italic> = min {<italic>s</italic><sub><italic>n</italic> − 1</sub>, <italic>s</italic><sub><italic>n</italic></sub>}</textual-form><mml:math id="M201" altimg="si264.gif" display="inline" overflow="scroll"><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mo>min</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and fix an overlap of <inline-formula><alternatives><textual-form specific-use="jats-markup">2 / 3 ⋅ 2<sup><italic>s</italic></sup></textual-form><mml:math id="M202" altimg="si265.gif" display="inline" overflow="scroll"><mml:mn>2</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>, if <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>s</italic><sub><italic>n</italic></sub> ≠ <italic>s</italic><sub><italic>n</italic> − 1</sub></textual-form><mml:math id="M203" altimg="si266.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup">1 / 3 ⋅ 2<sup><italic>s</italic></sup></textual-form><mml:math id="M204" altimg="si267.gif" display="inline" overflow="scroll"><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>, if <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>s</italic><sub><italic>n</italic></sub> = <italic>s</italic><sub><italic>n</italic> − 1</sub></textual-form><mml:math id="M205" altimg="si268.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. Explicitly, <disp-formula id="fd000165"><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub> = 𝒯<sub><italic>n</italic></sub><italic>D</italic><sub>2<sup><italic>s</italic><sub><italic>n</italic></sub></sup></sub>(<italic>g</italic>),</textual-form><mml:math id="M206" altimg="si269.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>D</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>,</mml:mtext></mml:math></alternatives></disp-formula> with recursively defined time shift operators <inline-formula><alternatives><textual-form specific-use="jats-markup">𝒯<sub><italic>n</italic></sub></textual-form><mml:math id="M207" altimg="si270.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> given by <disp-formula id="fd000170"><mml:math id="M208" altimg="si271.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mtext>,</mml:mtext><mml:mspace width="2em" class="qquad"/><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable class="cases"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msup><mml:mn>5</mml:mn><mml:mo>/</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mtext>if </mml:mtext><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mtext>else .</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula> Defining the time shifts in this manner, we achieve exactly the desired overlap as illustrated in <xref rid="f000025" ref-type="fig">Fig. 5</xref>.</p>
          <p>By construction, each <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic></sub></textual-form><mml:math id="M209" altimg="si272.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> has non-zero overlap with its neighbors <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic> − 1</sub></textual-form><mml:math id="M210" altimg="si273.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>g</italic><sub><italic>n</italic> + 1</sub></textual-form><mml:math id="M211" altimg="si274.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> and at any point on the real line, at most two windows are non-zero. After performing a preliminary transient detection step, as explained before, the construction of the adapted frame reduces to the determination of a scale sequence.</p>
          <p>In the subsequent figures and experiments, we used the Hann window as the prototype, but other window choices are possible. The described concept can easily be generalized by admitting other overlap factors and scaling ratio than the ones specified above. The parameters have to be chosen with some care, though. Otherwise, the resulting frames might be badly conditioned, with a big or even infinite condition number <inline-formula><mml:math id="M212" altimg="si275.gif" display="inline" overflow="scroll"><mml:mfrac><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:mfrac></mml:math></inline-formula>, caused by accumulation points for the time shifts or gaps between windows. A more detailed description of general and discrete scale frames is beyond the scope of this article and will be part of a future contribution.</p>
          <p><italic>Frame construction from a sequence of onsets</italic>. In this paragraph, we assume that the signals of interest are mainly comprised of transient and sinusoidal components, an assumption met, e.g. by piano music. The instant a piano key is hit corresponds to a percussive, transient sound event, directly followed by harmonic components, concentrated in frequency. An intuitive adaptation to signals of this type would use high time resolution at the positions of transients. This corresponds to applying minimal scale at the transients and steadily increasing the scale with the distance from the closest transient. The transients’ positions can be determined, e.g. by the so-called onset detection procedures <xref rid="br000165" ref-type="bibr">[33]</xref> which, if used carefully, work to a high degree of accuracy. Once the transient positions are known, the construction of a corresponding scale frame yields good nonstationary representations for sufficiently sparse signals.</p>
          <p><italic>Application of onset</italic>-<italic>based scale frames</italic>. We applied the procedure proposed above to various signals, mainly piano music. For this presentation, we selected three examples, all of them sampled at 44.1 kHz and consisting of a single channel. Some more examples and corresponding results as well as the source sound files can be found on the associated web-page <ext-link ext-link-type="uri" xlink:href="http://univie.ac.at/nonstatgab/" id="ir000025">http://univie.ac.at/nonstatgab/</ext-link>. <list list-type="simple"><list-item><label>•</label><p>Example 1: the widely used Glockenspiel signal shown in <xref rid="f000015" ref-type="fig">Fig. 3</xref>.</p></list-item><list-item><label>•</label><p>Example 2: an excerpt from a solo jazz piano piece performed by Herbie Hancock, characterized by its calmness and varied rhythmical pattern, resulting in irregularly spaced low-energy transients. See <xref rid="f000030" ref-type="fig">Fig. 6</xref>.</p></list-item><list-item><label>•</label><p>Example 3: a short excerpt of György Ligeti’s piano concert. With highly percussive onsets in the piano and Glockenspiel voices and some orchestral background, this is the most polyphonic of our examples. See <xref rid="f000035" ref-type="fig">Fig. 7</xref>.</p></list-item></list></p>
          <p>For comparison, the plots in <xref rid="f000015 f000030 f000035" ref-type="fig">Figs. 3, 6 and 7</xref> also show standard Gabor coefficients with comparable (average) window overlap. A Hann window of 2560 samples length was chosen for the computation of regular Gabor transforms. The comparison shows that for the three signals, the NSGT features a better concentration of transient energy than a regular Gabor transform, while keeping, or even improving, frequency resolution.</p>
          <p><italic>Efficiency in sparse reconstruction</italic>. The onset detection procedure and a subsequent scale frame analysis were applied, along with a regular Gabor decomposition, to the Glockenspiel and Ligeti signals. As a test of the representations’ sparsity, the signals were synthesized from their corresponding coefficients, modified by hard thresholding followed by reconstruction using the canonical dual frame. Then the numbers of largest magnitude coefficients needed for a certain relative root mean square (RMS) reconstruction error for each representation were compared. The RMS error of a vector <italic>f</italic> and its reconstruction <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic><sub>rec</sub></textual-form><mml:math id="M213" altimg="si277.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>rec</mml:mi></mml:mstyle></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> is given by <disp-formula id="fd000175"><mml:math id="M214" altimg="si278.gif" display="block" overflow="scroll"><mml:mstyle mathvariant="normal"><mml:mi>RMS</mml:mi></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>rec</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mfrac><mml:mrow><mml:munderover accentunder="false" accent="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>rec</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:munderover accentunder="false" accent="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:msqrt><mml:mtext>.</mml:mtext></mml:math></disp-formula> All transforms are of redundancy about <inline-formula><mml:math id="M215" altimg="si279.gif" display="inline" overflow="scroll"><mml:mfrac><mml:mrow><mml:mn>5</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:math></inline-formula>. The results for NSGT and different regular Gabor transform schemes are listed in <xref rid="f000040" ref-type="fig">Fig. 8</xref>. On the Glockenspiel signal the NSGT method performs vastly better than the ordinary Gabor transform. For Ligeti, the differences are not as significant, but still the NSGT-based procedure shows better overall results.</p>
          <p>Further experiments and a more exhaustive discussion of the parameters used in the experiments, can be found on the web-page <ext-link ext-link-type="uri" xlink:href="http://univie.ac.at/nonstatgab/" id="ir000030">http://univie.ac.at/nonstatgab/</ext-link>. Along with them, examples of regular and nonstationary reconstructions from a specified amount of coefficients can be found, so the reader might get a subjective impression of perceptive reconstruction quality. In conclusion, the experiments show that for real music signals, NSGT can provide a sparser representation than regular Gabor transforms, admitting reasonable reconstruction error.</p>
        </sec>
      </sec>
      <sec id="s000075">
        <label>4.2</label>
        <title>Implementation of a discrete, frequency-adaptive Gabor transform</title>
        <p>Since our construction of Gabor frames with adaptivity in the frequency domain relies on the fact that analysis windows <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic></sub></textual-form><mml:math id="M216" altimg="si280.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> possess compact bandwidth, an FFT-based implementation is highly efficient. We take the input signal’s Fourier transform and treat the procedure in complete analogy to the situation developed for time-adaptive transforms, i.e. <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic>, <italic>n</italic></sub>[<italic>k</italic>] = <italic>T</italic><sub><italic>n</italic><italic>a</italic><sub><italic>m</italic></sub></sub><italic>h</italic><sub><italic>m</italic></sub>[<italic>k</italic>]</textual-form><mml:math id="M217" altimg="si281.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>T</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula><mml:math id="M218" altimg="si282.gif" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>As observed in Section <xref rid="s000045" ref-type="sec">3.2.1</xref>, we are able to obtain wavelet frames using Gabor frames that exhibit nonstationarity in the frequency domain. Moreover, we may design general transforms with flexible frequency resolution, such as a constant-Q transform. While various other adjustments (e.g. Mel- or Bark-scaled transforms) are feasible, we will focus our discussion on the constant-Q case. To the best knowledge of the authors, the approach to implement the constant-Q transform directly in the frequency domain by means of FFT is new in audio processing. <statement id="e000055"><label>Remark 5</label><p>Note that for real-valued signals the symmetry of their FFT can be exploited to further reduce the computational effort. We particularly refer to the LTFAT routines filterbankrealdual.m and filterbankrealtight.m.</p></statement></p>
        <sec id="s000080">
          <label>4.2.1</label>
          <title>Application: an invertible constant-Q transform</title>
          <p>The constant-Q transform (CQT), introduced in <xref rid="br000170" ref-type="bibr">[34]</xref>, transforms a time signal into the time–frequency domain, where the center frequencies of the frequency bins are geometrically spaced. Since the <italic>Q</italic>-<italic>factor</italic> (the ratio of the center frequencies to the window’s bandwidth) is constant, the representation allows for a better frequency resolution at lower frequencies and a better time resolution at the higher frequencies. This is sometimes preferable to the fixed resolution of the standard Gabor transform, for which the frequency bins are linearly spaced. In particular, this kind of resolution is often desired in the analysis of musical signals, since the transform can be set to coincide the temperament, e.g. semitone or quarter tone, used in Western music.</p>
          <p>The originally introduced constant-Q transform, however, is not invertible and is computationally more intensive than the DFT. A computationally more efficient approach was presented in the sequel <xref rid="br000015" ref-type="bibr">[3]</xref>: for the <italic>n</italic>th time slice of the signal <italic>f</italic>, the coefficient vector <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>c</italic><sub><italic>m</italic>, <italic>n</italic></sub></textual-form><mml:math id="M219" altimg="si286.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, equal to inner product of the signal <italic>f</italic> with the <italic>time</italic>-limited window <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic>, <italic>n</italic></sub></textual-form><mml:math id="M220" altimg="si288.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> is computed in the Fourier side via <inline-formula><mml:math id="M221" altimg="si289.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>. This approximate computation takes advantage of the sparsity of the frequency domain kernel or <italic>spectral kernel</italic>. In contrast, we compute the coefficient vector for each frequency bin, making use of <italic>band</italic>-limited window functions.</p>
          <p>Perfect reconstruction wavelet transforms with rational dilation factors were proposed in <xref rid="br000175" ref-type="bibr">[35]</xref>. Since they are based on iterated filter banks, these methods are computationally too expensive for long, real-life signals, when high <italic>Q</italic>-factors, such as 12–96 bins per octave, are required.</p>
          <p>In <xref rid="br000150" ref-type="bibr">[30]</xref>, Klapuri and Schörkhuber presented a computation of the CQT that shows improved efficiency and flexibility compared to the method proposed in <xref rid="br000015" ref-type="bibr">[3]</xref>, among others. However, the approximate inversion introduced in <xref rid="br000150" ref-type="bibr">[30]</xref> still gives an RMS error of around 10<sup>−3</sup>. The lack of perfect invertibility prevents the convenient modification of CQT-coefficients with subsequent resynthesis required in complex music processing tasks such as masking or transposition. By allowing adaptive resolution in frequency, we can construct an invertible nonstationary Gabor transform with a constant <italic>Q</italic>-factor on the relevant frequency bins.</p>
          <p><italic>Setting</italic>. For the frame elements in the transform, we consider functions <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic></sub> ∈ ℂ<sup><italic>L</italic></sup>,  <italic>m</italic> = 1, …, <italic>M</italic></textual-form><mml:math id="M222" altimg="si292.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace class="nbsp"/><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi></mml:math></alternatives></inline-formula> having center frequencies (in Hz) at <inline-formula><mml:math id="M223" altimg="si293.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:math></inline-formula>, as in the CQT. Here, <italic>B</italic> is the number of frequency bins per octave, and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ξ</italic><sub>min</sub></textual-form><mml:math id="M224" altimg="si295.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ξ</italic><sub>max</sub></textual-form><mml:math id="M225" altimg="si296.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>max</mml:mi></mml:mstyle></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> are the desired minimum and maximum frequencies, respectively. In the experiments, we restrict <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ξ</italic><sub>max</sub></textual-form><mml:math id="M226" altimg="si297.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>max</mml:mi></mml:mstyle></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> to be less than the Nyquist frequency and there should exist an <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>M</italic> ∈ ℕ</textual-form><mml:math id="M227" altimg="si298.gif" display="inline" overflow="scroll"><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:math></alternatives></inline-formula> satisfying <inline-formula><mml:math id="M228" altimg="si299.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>max</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:math></inline-formula>, where <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ξ</italic><sub><italic>s</italic></sub></textual-form><mml:math id="M229" altimg="si300.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> denotes the sampling frequency. In this case, we take <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>M</italic> = ⌈<italic>B</italic>log<sub>2</sub>(<italic>ξ</italic><sub>max</sub> / <italic>ξ</italic><sub>min</sub>) + 1⌉</textual-form><mml:math id="M230" altimg="si301.gif" display="inline" overflow="scroll"><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>max</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>⌉</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula><alternatives><textual-form specific-use="jats-markup">⌈<italic>z</italic>⌉</textual-form><mml:math id="M231" altimg="si302.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>⌈</mml:mo><mml:mi>z</mml:mi><mml:mo>⌉</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is the smallest integer greater than or equal to <italic>z</italic>. While in the CQT no 0-frequency is present, the NSGT provides all necessary freedom to use additional center frequencies. Since the signals of interest are real-valued, we put filters at center frequencies beyond the Nyquist frequency in a symmetric manner. This results in the following values for the center frequencies: <disp-formula id="fd000180"><mml:math id="M232" altimg="si304.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable class="cases"><mml:mtr><mml:mtd><mml:mn>0</mml:mn><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mtext>.</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
          <p>For the corresponding bandwidth <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>Ω</italic><sub><italic>m</italic></sub></textual-form><mml:math id="M233" altimg="si305.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>Ω</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> of <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic></sub></textual-form><mml:math id="M234" altimg="si306.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, we set <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>Ω</italic><sub><italic>m</italic></sub> = <italic>ξ</italic><sub><italic>m</italic> + 1</sub> − <italic>ξ</italic><sub><italic>m</italic> − 1</sub></textual-form><mml:math id="M235" altimg="si307.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>Ω</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, for <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>m</italic> = 1, …, <italic>M</italic></textual-form><mml:math id="M236" altimg="si308.gif" display="inline" overflow="scroll"><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi></mml:math></alternatives></inline-formula>, and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>Ω</italic><sub>0</sub> = 2<italic>ξ</italic><sub>1</sub> = 2<italic>ξ</italic><sub>min</sub></textual-form><mml:math id="M237" altimg="si309.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>Ω</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. By construction, these result in a constant <italic>Q</italic>-factor <inline-formula><mml:math id="M238" altimg="si311.gif" display="inline" overflow="scroll"><mml:mi>Q</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> for <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>m</italic> = 2, …, <italic>M</italic> − 1</textual-form><mml:math id="M239" altimg="si312.gif" display="inline" overflow="scroll"><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:math></alternatives></inline-formula>. And we can write each <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>Ω</italic><sub><italic>m</italic></sub></textual-form><mml:math id="M240" altimg="si313.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>Ω</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> as follows: <disp-formula id="fd000185"><mml:math id="M241" altimg="si314.gif" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>Ω</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable class="cases"><mml:mtr><mml:mtd><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mi>Q</mml:mi><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msub><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mi>Q</mml:mi><mml:mtext>,</mml:mtext></mml:mtd><mml:mtd><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>M</mml:mi><mml:mtext>.</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
          <p>If we use a Hann window <inline-formula><mml:math id="M242" altimg="si315.gif" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:math></inline-formula>, supported on <inline-formula><alternatives><textual-form specific-use="jats-markup">[ − 1 / 2, 1 / 2]</textual-form><mml:math id="M243" altimg="si316.gif" display="inline" overflow="scroll"><mml:mrow><mml:mo>[</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, then we can obtain each <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic></sub></textual-form><mml:math id="M244" altimg="si317.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> via <inline-formula><mml:math id="M245" altimg="si318.gif" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>Ω</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>j</italic> = 0, …, <italic>L</italic> − 1</textual-form><mml:math id="M246" altimg="si319.gif" display="inline" overflow="scroll"><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:math></alternatives></inline-formula>. Letting <inline-formula><mml:math id="M247" altimg="si320.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Ω</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math></inline-formula>, we define <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>h</italic><sub><italic>m</italic>, <italic>n</italic></sub></textual-form><mml:math id="M248" altimg="si321.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> by their Fourier transform <inline-formula><mml:math id="M249" altimg="si322.gif" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mi>M</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mfrac><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula>. <xref rid="f000045" ref-type="fig">Fig. 9</xref> illustrates the time–frequency sampling grid of the set-up, where the center frequencies are geometrically spaced and sampling points regularly spaced.</p>
          <p>The support conditions on <inline-formula><mml:math id="M250" altimg="si323.gif" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:math></inline-formula> imply that the sum <inline-formula><mml:math id="M251" altimg="si324.gif" display="inline" overflow="scroll"><mml:mi>σ</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mfrac><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> is finite and bounded away from 0. From Section <xref rid="s000050" ref-type="sec">3.3</xref>, the frame operator is therefore invertible and we can apply <xref rid="e000030" ref-type="statement">Corollary 2</xref>.</p>
          <p>Note that we consider the bandwidth to be the support of the window in frequency. This makes sense in the considered painless case. Very often, see e.g. <xref rid="br000150" ref-type="bibr">[30]</xref>, the bandwidth is taken as the width between the points, where the filter response drops to half of the maximum, i.e. the −3 dB-bandwidth. This definition would also make sense in a non-compactly supported case. For the chosen filters, Hann windows, the <italic>Q</italic>-factor considering the −3 dB-bandwidth is just double of the one considered above.</p>
          <p>We see in <xref rid="f000050" ref-type="fig">Fig. 10</xref> the standard Gabor transform spectrogram and the constant-Q NSGT spectrogram of the Glockenspiel signal, the latter being very similar to the CQT spectrogram obtained from the original algorithm <xref rid="br000170" ref-type="bibr">[34]</xref> but with the additional property that the signal can be perfectly reconstructed from the coefficients. <xref rid="f000055 f000060" ref-type="fig">Figs. 11 and 12</xref> compare the standard Gabor transform spectrogram and the constant-Q NSGT spectrogram of two additional test signals, both sampled at 44.1 kHz. <list list-type="simple"><list-item><label>•</label><p>Example 4: a recording of Bach’s Little Fugue in G Minor, BWV578 performed by Christopher Herrick on a pipe organ. Low frequency noise and the characteristic structure of pipe organ notes are resolved very well by a CQT. See <xref rid="f000055" ref-type="fig">Fig. 11</xref>.</p></list-item><list-item><label>•</label><p>Example 5: an excerpt from a duet between violin and piano. Written by John Zorn and performed by Sylvie Courvoisier and Mark Feldman, the sample is made up of three short segments: a frantic sequence of violin and piano notes, a slow violin melody with piano backing and an inharmonic part with chirp component. See <xref rid="f000060" ref-type="fig">Fig. 12</xref>.</p></list-item></list><italic>Efficiency</italic>: The computation time of the nonstationary Gabor transform was found to be better than a recent fast CQT implementation <xref rid="br000150" ref-type="bibr">[30]</xref>, as seen in <xref rid="f000065" ref-type="fig">Fig. 13</xref>. The two plots show mean values for computation time in seconds and the corresponding variance over 50 iterations, with varying window lengths and number of frequency bins, respectively. The outlier, drawn in gray, in <xref rid="f000065" ref-type="fig">Fig. 13</xref> (left) at the prime number 600 569 illustrates dependence of the current CQ-NSGT implementation on the signal length’s prime factor structure, analogous to FFT.</p>
          <p>It is again reasonable to assume that the number of filters is bounded, independently of <italic>L</italic>, while the number of temporal points depend on <italic>L</italic>. As the role of <italic>M</italic> and <italic>N</italic> is switched in the assumption in Section <xref rid="s000065" ref-type="sec">4.1.1</xref> for the complexity, we arrive at a complexity of <inline-formula><alternatives><textual-form specific-use="jats-markup">𝒪(<italic>L</italic>log<italic>L</italic>)</textual-form><mml:math id="M252" altimg="si330.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>L</mml:mi><mml:mo>log</mml:mo><mml:mi>L</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. This is also the complexity of the FFT of the whole signal. So the overall complexity of the frequency-dependent nonstationary Gabor transform is <inline-formula><alternatives><textual-form specific-use="jats-markup">𝒪(<italic>L</italic>log<italic>L</italic>)</textual-form><mml:math id="M253" altimg="si331.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>L</mml:mi><mml:mo>log</mml:mo><mml:mi>L</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. The advantage of the method in terms of computational efficiency thus decreases as longer signals are considered.</p>
          <p>We note that at this point, since the windows used are band-limited, the current procedure is not suitable for real-time processing, despite its efficiency. The next step would be to process the incoming samples in a piecewise manner, using only a single family of frame elements for signals of arbitrary length. This entails working on finite, discrete parts of the given signal, thus considering the Fourier-transformed versions of vectors <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>f</italic> ⋅ <italic>h</italic> ∈ ℂ<sup>ℒ</sup></textual-form><mml:math id="M254" altimg="si332.gif" display="inline" overflow="scroll"><mml:mi>f</mml:mi><mml:mo>⋅</mml:mo><mml:mi>h</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>, where <italic>h</italic> denotes some function of length <inline-formula><alternatives><textual-form specific-use="jats-markup">ℒ ≪ <italic>L</italic></textual-form><mml:math id="M255" altimg="si334.gif" display="inline" overflow="scroll"><mml:mi mathvariant="script">L</mml:mi><mml:mo>≪</mml:mo><mml:mi>L</mml:mi></mml:math></alternatives></inline-formula>. This window, together with the frame elements, will be designed to minimize undesired effects that stem from the cutting of the signal. Details of this piecewise processing, as well as a proposed <italic>variable-Q</italic> transform, will be further discussed in a future contribution.</p>
        </sec>
      </sec>
    </sec>
    <sec id="s000085">
      <label>5</label>
      <title>Conclusion and perspectives</title>
      <p>Our approach enables the construction of frames with flexible evolution of time–frequency resolution over time or frequency. The resulting frames are well suited for applications as they can be implemented using fast algorithms, at a computational cost close to standard Gabor frames.</p>
      <p>Exploiting evolution of resolution over time, the proposed approach can be of particular interest for applications where the frequency characteristics of the signal are known to evolve significantly with time. Order analysis <xref rid="br000180" ref-type="bibr">[36]</xref>, in which the signal analyzed is produced by a rotating machine having changing rotating speed, is an example of such an application.</p>
      <p>Exploiting evolution of resolution over frequency, the presented approach is valuable for applications requiring the use of a tailored non uniform filter bank. In particular, it can be used to build filter banks following some perceptive frequency scale; see e.g. <xref rid="br000025" ref-type="bibr">[5]</xref>. In the present contribution, we described in detail an invertible constant-Q transform.</p>
      <p>One difficulty when using our approach is to adapt the time–frequency resolution to the evolution of the signal characteristics. If prior knowledge is available, this can be done by hand. An automatic adaptation algorithm based on onset detection was described in Section <xref rid="s000070" ref-type="sec">4.1.2</xref>. A different approach will involve the investigation of sparsity criteria as proposed in <xref rid="br000155" ref-type="bibr">[31]</xref>. Finally, future work will lead to adaptability in both time and frequency leading to <italic>quilted frames</italic> as introduced in <xref rid="br000185" ref-type="bibr">[37]</xref>.</p>
    </sec>
  </body>
  <back>
    <ref-list>
      <title>References</title>
      <ref id="br000005">
        <label>1</label>
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Feichtinger</surname>
              <given-names>H.G.</given-names>
            </name>
            <name>
              <surname>Strohmer</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <chapter-title>Gabor Analysis and Algorithms—Theory and Applications</chapter-title>
          <year>1998</year>
          <publisher-name>Birkhäuser</publisher-name>
          <publisher-loc>Boston</publisher-loc>
        </element-citation>
      </ref>
      <ref id="br000010">
        <label>2</label>
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Daubechies</surname>
              <given-names>I.</given-names>
            </name>
          </person-group>
          <source>Ten Lectures on Wavelets</source>
          <series>CBMS-NSF Regional Conference Series in Applied Mathematics</series>
          <year>1992</year>
          <publisher-name>SIAM</publisher-name>
          <publisher-loc>Philadelphia</publisher-loc>
        </element-citation>
      </ref>
      <ref id="br000015">
        <label>3</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Brown</surname>
              <given-names>J.C.</given-names>
            </name>
            <name>
              <surname>Puckette</surname>
              <given-names>M.S.</given-names>
            </name>
          </person-group>
          <article-title>An efficient algorithm for the calculation of a constant <italic>Q</italic> transform</article-title>
          <source>J. Acoust. Soc. Am.</source>
          <volume>92</volume>
          <year>1992</year>
          <fpage>2698</fpage>
          <lpage>2701</lpage>
        </element-citation>
      </ref>
      <ref id="br000020">
        <label>4</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Bölcskei</surname>
              <given-names>H.</given-names>
            </name>
            <name>
              <surname>Hlawatsch</surname>
              <given-names>F.</given-names>
            </name>
            <name>
              <surname>Feichtinger</surname>
              <given-names>H.G.</given-names>
            </name>
          </person-group>
          <article-title>Frame-theoretic analysis of oversampled filter banks</article-title>
          <source>IEEE Trans. Signal Process.</source>
          <volume>46</volume>
          <year>1998</year>
          <fpage>3256</fpage>
          <lpage>3268</lpage>
        </element-citation>
      </ref>
      <ref id="br000025">
        <label>5</label>
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Hartmann</surname>
              <given-names>W.M.</given-names>
            </name>
          </person-group>
          <chapter-title>Signals, Sounds, and Sensation</chapter-title>
          <year>1998</year>
          <publisher-name>Springer</publisher-name>
        </element-citation>
      </ref>
      <ref id="br000030">
        <label>6</label>
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Malvar</surname>
              <given-names>H.</given-names>
            </name>
          </person-group>
          <chapter-title>Signal Processing with Lapped Transforms</chapter-title>
          <year>1992</year>
          <publisher-name>Artech House</publisher-name>
          <publisher-loc>Boston, MA</publisher-loc>
          <comment>xvi</comment>
        </element-citation>
      </ref>
      <ref id="br000035">
        <label>7</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Wesfreid</surname>
              <given-names>E.</given-names>
            </name>
            <name>
              <surname>Wickerhauser</surname>
              <given-names>M.V.</given-names>
            </name>
          </person-group>
          <article-title>Adapted local trigonometric transforms and speech processing</article-title>
          <source>IEEE Trans. Signal Process.</source>
          <volume>41</volume>
          <year>1993</year>
          <fpage>3596</fpage>
          <lpage>3600</lpage>
        </element-citation>
      </ref>
      <ref id="br000040">
        <label>8</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ramchandran</surname>
              <given-names>K.</given-names>
            </name>
            <name>
              <surname>Xiong</surname>
              <given-names>Z.</given-names>
            </name>
            <name>
              <surname>Herley</surname>
              <given-names>C.</given-names>
            </name>
            <name>
              <surname>Orchard</surname>
              <given-names>M.</given-names>
            </name>
          </person-group>
          <article-title>Flexible tree-structured signal expansions using time-varying wavelet packets</article-title>
          <source>IEEE Trans. Signal Process.</source>
          <volume>45</volume>
          <year>1997</year>
          <fpage>233</fpage>
          <lpage>245</lpage>
        </element-citation>
      </ref>
      <ref id="br000045">
        <label>9</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Rudoy</surname>
              <given-names>D.</given-names>
            </name>
            <name>
              <surname>Prabahan</surname>
              <given-names>B.</given-names>
            </name>
            <name>
              <surname>Wolfe</surname>
              <given-names>P.</given-names>
            </name>
          </person-group>
          <article-title>Superposition frames for adaptive time–frequency analysis and fast reconstruction</article-title>
          <source>IEEE Trans. Signal Process.</source>
          <volume>58</volume>
          <year>2010</year>
          <fpage>2581</fpage>
          <lpage>2596</lpage>
        </element-citation>
      </ref>
      <ref id="br000050">
        <label>10</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Daubechies</surname>
              <given-names>I.</given-names>
            </name>
            <name>
              <surname>Grossmann</surname>
              <given-names>A.</given-names>
            </name>
            <name>
              <surname>Meyer</surname>
              <given-names>Y.</given-names>
            </name>
          </person-group>
          <article-title>Painless nonorthogonal expansions</article-title>
          <source>J. Math. Phys.</source>
          <volume>27</volume>
          <year>1986</year>
          <fpage>1271</fpage>
          <lpage>1283</lpage>
        </element-citation>
      </ref>
      <ref id="br000055">
        <label>11</label>
        <mixed-citation publication-type="other">F. Jaillet, Représentation et traitement temps-fréquence des signaux audionumériques pour des applications de design sonore, Ph.D. Thesis, Université de la Méditerranée Aix-Marseille II, 2005.</mixed-citation>
      </ref>
      <ref id="br000060">
        <label>12</label>
        <mixed-citation publication-type="other">F. Jaillet, P. Balazs, M. Dörfler, N. Engelputzeder, Nonstationary Gabor frames, in: Proceedings of the 8th International Conference on Sampling Theory and Applications, SampTA, 2009, pp. 227–230.</mixed-citation>
      </ref>
      <ref id="br000065">
        <label>13</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Vandewalle</surname>
              <given-names>P.</given-names>
            </name>
            <name>
              <surname>Kovac˘ević</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Vetterli</surname>
              <given-names>M.</given-names>
            </name>
          </person-group>
          <article-title>Reproducible research in signal processing</article-title>
          <source>IEEE Signal Process. Mag.</source>
          <volume>26</volume>
          <year>2009</year>
          <fpage>37</fpage>
          <lpage>47</lpage>
        </element-citation>
      </ref>
      <ref id="br000070">
        <label>14</label>
        <mixed-citation publication-type="other">P.L. Søndergaard, Finite discrete Gabor analysis, Ph.D. Thesis, Technical University of Denmark, Lyngby, 2007.</mixed-citation>
      </ref>
      <ref id="br000075">
        <label>15</label>
        <mixed-citation publication-type="other">P.L. Søndergaard, B. Torrésani, P. Balazs, The linear time frequency analysis toolbox, Int. J. Wavelets Multiresolut. Inf. Process. (2011) (in press).</mixed-citation>
      </ref>
      <ref id="br000080">
        <label>16</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Duffin</surname>
              <given-names>R.J.</given-names>
            </name>
            <name>
              <surname>Schaeffer</surname>
              <given-names>A.C.</given-names>
            </name>
          </person-group>
          <article-title>A class of nonharmonic Fourier series</article-title>
          <source>Trans. Amer. Math. Soc.</source>
          <volume>72</volume>
          <year>1952</year>
          <fpage>341</fpage>
          <lpage>366</lpage>
        </element-citation>
      </ref>
      <ref id="br000085">
        <label>17</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Casazza</surname>
              <given-names>P.G.</given-names>
            </name>
          </person-group>
          <article-title>The art of frame theory</article-title>
          <source>Taiwanese J. Math.</source>
          <volume>4</volume>
          <year>2000</year>
          <fpage>129</fpage>
          <lpage>202</lpage>
        </element-citation>
      </ref>
      <ref id="br000090">
        <label>18</label>
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Christensen</surname>
              <given-names>O.</given-names>
            </name>
          </person-group>
          <chapter-title>An Introduction to Frames and Riesz Bases</chapter-title>
          <year>2003</year>
          <publisher-name>Birkhäuser</publisher-name>
        </element-citation>
      </ref>
      <ref id="br000095">
        <label>19</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Gabor</surname>
              <given-names>D.</given-names>
            </name>
          </person-group>
          <article-title>Theory of communications</article-title>
          <source>J. IEE</source>
          <volume>93</volume>
          <issue>26</issue>
          <year>1946</year>
          <fpage>429</fpage>
          <lpage>457</lpage>
        </element-citation>
      </ref>
      <ref id="br000100">
        <label>20</label>
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Gröchenig</surname>
              <given-names>K.</given-names>
            </name>
          </person-group>
          <chapter-title>Foundations of Time-Frequency Analysis</chapter-title>
          <year>2001</year>
          <publisher-name>Birkhäuser</publisher-name>
          <publisher-loc>Boston</publisher-loc>
        </element-citation>
      </ref>
      <ref id="br000105">
        <label>21</label>
        <mixed-citation publication-type="other">T. Strohmer, Numerical algorithms for discrete Gabor expansions, in: <xref rid="br000005" ref-type="bibr">[1]</xref>, pp. 267–294.</mixed-citation>
      </ref>
      <ref id="br000110">
        <label>22</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Casazza</surname>
              <given-names>P.G.</given-names>
            </name>
            <name>
              <surname>Christensen</surname>
              <given-names>O.</given-names>
            </name>
          </person-group>
          <article-title>Gabor frames over irregular lattices</article-title>
          <source>Adv. Comput. Math.</source>
          <volume>18</volume>
          <year>2003</year>
          <fpage>329</fpage>
          <lpage>344</lpage>
        </element-citation>
      </ref>
      <ref id="br000115">
        <label>23</label>
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Mallat</surname>
              <given-names>S.</given-names>
            </name>
          </person-group>
          <chapter-title>A Wavelet Tour of Signal Processing</chapter-title>
          <year>1998</year>
          <publisher-name>Academic Press</publisher-name>
          <publisher-loc>London</publisher-loc>
        </element-citation>
      </ref>
      <ref id="br000120">
        <label>24</label>
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Gröchenig</surname>
              <given-names>K.</given-names>
            </name>
          </person-group>
          <source>Foundations of Time-Frequency Analysis</source>
          <series>Appl. Numer. Harmon. Anal.</series>
          <year>2001</year>
          <publisher-name>Birkhäuser</publisher-name>
          <publisher-loc>Boston</publisher-loc>
        </element-citation>
      </ref>
      <ref id="br000125">
        <label>25</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Gröchenig</surname>
              <given-names>K.</given-names>
            </name>
          </person-group>
          <article-title>Localization of frames, Banach frames, and the invertibility of the frame operator</article-title>
          <source>J. Fourier Anal. Appl.</source>
          <volume>10</volume>
          <year>2004</year>
          <fpage>105</fpage>
          <lpage>132</lpage>
        </element-citation>
      </ref>
      <ref id="br000130">
        <label>26</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ehler</surname>
              <given-names>M.</given-names>
            </name>
          </person-group>
          <article-title>On multivariate compactly supported bi-frames</article-title>
          <source>J. Fourier Anal. Appl.</source>
          <volume>13</volume>
          <year>2007</year>
          <fpage>511</fpage>
          <lpage>532</lpage>
        </element-citation>
      </ref>
      <ref id="br000135">
        <label>27</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ehler</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Han</surname>
              <given-names>B.</given-names>
            </name>
          </person-group>
          <article-title>Wavelet bi-frames with few generators from multivariate refinable functions</article-title>
          <source>Appl. Comput. Harmon. Anal.</source>
          <volume>25</volume>
          <year>2008</year>
          <fpage>407</fpage>
          <lpage>414</lpage>
        </element-citation>
      </ref>
      <ref id="br000140">
        <label>28</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ehler</surname>
              <given-names>M.</given-names>
            </name>
          </person-group>
          <article-title>Nonlinear approximation associated with nonseparable wavelet bi-frames</article-title>
          <source>J. Approx. Theory</source>
          <volume>161</volume>
          <year>2009</year>
          <fpage>292</fpage>
          <lpage>313</lpage>
        </element-citation>
      </ref>
      <ref id="br000145">
        <label>29</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ehler</surname>
              <given-names>M.</given-names>
            </name>
          </person-group>
          <article-title>The multiresolution structure of pairs of dual wavelet frames for a pair of sobolev spaces</article-title>
          <source>Jaen J. Approx.</source>
          <volume>2</volume>
          <year>2010</year>
          <fpage>193</fpage>
          <lpage>214</lpage>
        </element-citation>
      </ref>
      <ref id="br000150">
        <label>30</label>
        <mixed-citation publication-type="other">C. Schörkhuber, A. Klapuri, Constant-<italic>Q</italic> toolbox for music processing, in: Proceedings of the 7th Sound and Music Computing Conference, SMC, 2010.</mixed-citation>
      </ref>
      <ref id="br000155">
        <label>31</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Jaillet</surname>
              <given-names>F.</given-names>
            </name>
            <name>
              <surname>Torrésani</surname>
              <given-names>B.</given-names>
            </name>
          </person-group>
          <article-title>Time-frequency jigsaw puzzle: adaptive multiwindow and multilayered gabor representations</article-title>
          <source>Int. J. Wavelets Multiresolut. Inf. Process.</source>
          <volume>5</volume>
          <year>2007</year>
          <fpage>293</fpage>
          <lpage>316</lpage>
        </element-citation>
      </ref>
      <ref id="br000160">
        <label>32</label>
        <mixed-citation publication-type="other">M. Liuni, A. Röbel, M. Romito, X. Rodet, Rényi information measures for spectral change detection, in: Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing, ICASSP, 2011, pp. 3824–3827.</mixed-citation>
      </ref>
      <ref id="br000165">
        <label>33</label>
        <mixed-citation publication-type="other">S. Dixon, Onset detection revisited, in: Proceedings of the 9th International Conference on Digital Audio Effects, DAFx, 2006, pp. 133–137.</mixed-citation>
      </ref>
      <ref id="br000170">
        <label>34</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Brown</surname>
              <given-names>J.</given-names>
            </name>
          </person-group>
          <article-title>Calculation of a constant <italic>Q</italic> spectral transform</article-title>
          <source>J. Acoust. Soc. Am.</source>
          <volume>89</volume>
          <year>1991</year>
          <fpage>425</fpage>
          <lpage>434</lpage>
        </element-citation>
      </ref>
      <ref id="br000175">
        <label>35</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Bayram</surname>
              <given-names>İ.</given-names>
            </name>
            <name>
              <surname>Selesnick</surname>
              <given-names>I.W.</given-names>
            </name>
          </person-group>
          <article-title>Frequency-domain design of overcomplete rational-dilation wavelet transforms</article-title>
          <source>IEEE Trans. Signal Process.</source>
          <volume>57</volume>
          <year>2009</year>
          <fpage>2957</fpage>
          <lpage>2972</lpage>
        </element-citation>
      </ref>
      <ref id="br000180">
        <label>36</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Shao</surname>
              <given-names>H.</given-names>
            </name>
            <name>
              <surname>Jin</surname>
              <given-names>W.</given-names>
            </name>
            <name>
              <surname>Qian</surname>
              <given-names>S.</given-names>
            </name>
          </person-group>
          <article-title>Order tracking by discrete Gabor expansion</article-title>
          <source>IEEE Trans. Instrum. Meas.</source>
          <volume>52</volume>
          <year>2003</year>
          <fpage>754</fpage>
          <lpage>761</lpage>
        </element-citation>
      </ref>
      <ref id="br000185">
        <label>37</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Dörfler</surname>
              <given-names>M.</given-names>
            </name>
          </person-group>
          <article-title>Quilted Gabor frames—a new concept for adaptive time–frequency representation</article-title>
          <source>Adv. Appl. Math.</source>
          <volume>47</volume>
          <year>2011</year>
          <fpage>668</fpage>
          <lpage>687</lpage>
        </element-citation>
      </ref>
    </ref-list>
    <ack>
      <title>Acknowledgments</title>
      <p>This work was supported by the WWTF projects <italic>Audiominer</italic> (MA09-24) and <italic>MulAc</italic> (MA07-025), the Austrian Science Fund (FWF):[T384-N13] and [S10602-N13]. We thank two anonymous reviewers for their valuable comments and suggestions.</p>
    </ack>
  </back>
  <floats-group>
    <fig id="f000005">
      <label>Fig. 1</label>
      <caption>
        <p>Example of a sampling grid of the time–frequency plane when building a decomposition with time–frequency resolution evolving over time.</p>
      </caption>
      <graphic xlink:href="gr1"/>
    </fig>
    <fig id="f000010">
      <label>Fig. 2</label>
      <caption>
        <p>Glockenspiel (Example 1). Gabor representations with short window (11.6 ms), resp. long window (185.8 ms).</p>
      </caption>
      <graphic xlink:href="gr2"/>
    </fig>
    <fig id="f000015">
      <label>Fig. 3</label>
      <caption>
        <p>Glockenspiel (Example 1). Regular Gabor representation with a Hann window of 58 ms length and a nonstationary Gabor representation using Hann windows of varying length.</p>
      </caption>
      <graphic xlink:href="gr3"/>
    </fig>
    <fig id="f000020">
      <label>Fig. 4</label>
      <caption>
        <p>Example of a sampling grid of the time–frequency plane when building a decomposition with time–frequency resolution changing over frequency.</p>
      </caption>
      <graphic xlink:href="gr4"/>
    </fig>
    <fig id="f000025">
      <label>Fig. 5</label>
      <caption>
        <p>Illustration of scale frame overlaps and time shifts.</p>
      </caption>
      <graphic xlink:href="gr5"/>
    </fig>
    <fig id="f000030">
      <label>Fig. 6</label>
      <caption>
        <p>Hancock (Example 2). Regular and nonstationary Gabor representations.</p>
      </caption>
      <graphic xlink:href="gr6"/>
    </fig>
    <fig id="f000035">
      <label>Fig. 7</label>
      <caption>
        <p>Ligeti (Example 3). Regular and nonstationary Gabor representations.</p>
      </caption>
      <graphic xlink:href="gr7"/>
    </fig>
    <fig id="f000040">
      <label>Fig. 8</label>
      <caption>
        <p>RMS error in sparse representations of Example 1 and Example 3. Parameters (in parentheses) are hop size and window length in the regular case (GT) or shortest window length and number of scales for the nonstationary case (NSGT). The values are estimated to be the optimal numbers of coefficients necessary to achieve reconstruction with less than the respective error.</p>
      </caption>
      <graphic xlink:href="gr8"/>
    </fig>
    <fig id="f000045">
      <label>Fig. 9</label>
      <caption>
        <p>Exemplary sampling grid of the time–frequency plane for a constant-Q nonstationary Gabor system.</p>
      </caption>
      <graphic xlink:href="gr9"/>
    </fig>
    <fig id="f000050">
      <label>Fig. 10</label>
      <caption>
        <p>Glockenspiel (Example 1). Regular Gabor, constant-Q nonstationary Gabor and constant-Q representations of the signal. The transform parameters were <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>B</italic> = 48</textual-form><mml:math id="M256" altimg="si1.gif" display="inline" overflow="scroll"><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mn>48</mml:mn></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ξ</italic><sub>min</sub> = 200 Hz</textual-form><mml:math id="M257" altimg="si2.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>200</mml:mn><mml:mspace class="nbsp"/><mml:mstyle mathvariant="normal"><mml:mi>Hz</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>.</p>
      </caption>
      <graphic xlink:href="gr10"/>
    </fig>
    <fig id="f000055">
      <label>Fig. 11</label>
      <caption>
        <p>Bach’s Little Fugue (Example 4). Regular and constant-Q nonstationary Gabor representations of the signal. The transform parameters were <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>B</italic> = 48</textual-form><mml:math id="M258" altimg="si3.gif" display="inline" overflow="scroll"><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mn>48</mml:mn></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ξ</italic><sub>min</sub> = 75 Hz</textual-form><mml:math id="M259" altimg="si4.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>75</mml:mn><mml:mspace class="nbsp"/><mml:mstyle mathvariant="normal"><mml:mi>Hz</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>.</p>
      </caption>
      <graphic xlink:href="gr11"/>
    </fig>
    <fig id="f000060">
      <label>Fig. 12</label>
      <caption>
        <p>Violin and piano duet (Example 5). Regular and constant-Q nonstationary Gabor representations of the signal. The transform parameters were <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>B</italic> = 48</textual-form><mml:math id="M260" altimg="si5.gif" display="inline" overflow="scroll"><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mn>48</mml:mn></mml:math></alternatives></inline-formula> and <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ξ</italic><sub>min</sub> = 50 Hz</textual-form><mml:math id="M261" altimg="si6.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>50</mml:mn><mml:mspace class="nbsp"/><mml:mstyle mathvariant="normal"><mml:mi>Hz</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>.</p>
      </caption>
      <graphic xlink:href="gr12"/>
    </fig>
    <fig id="f000065">
      <label>Fig. 13</label>
      <caption>
        <p>Comparison of computation time of CQT (top curves) and NSGT (bottom curves). The figure on the left shows the computation times for signals of various lengths with the number of bins per octave fixed at <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>B</italic> = 48</textual-form><mml:math id="M262" altimg="si7.gif" display="inline" overflow="scroll"><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mn>48</mml:mn></mml:math></alternatives></inline-formula>, while the figure on the right shows the computation times for the Glockenspiel signal, varying the number of bins per octave. In both figures, the solid lines represent the mean time (in seconds) and the dashed or dotted lines signify the mean time with corresponding variance. The lower left curve also shows gray solid lines indicating an outlier. The minimum frequency for all cases <inline-formula><alternatives><textual-form specific-use="jats-markup"><italic>ξ</italic><sub>min</sub></textual-form><mml:math id="M263" altimg="si8.gif" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mstyle mathvariant="normal"><mml:mi>min</mml:mi></mml:mstyle></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> was chosen at 50 Hz.</p>
      </caption>
      <graphic xlink:href="gr13"/>
    </fig>
  </floats-group>
</article>